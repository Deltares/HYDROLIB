from typing import List, Union

import numpy as np
from shapely.geometry import LineString, MultiLineString, MultiPolygon, Polygon
from shapely.wkt import loads,dumps

from hydrolib.core.io.net.models import Branch, Network
from hydrolib.dhydamo.geometry import common
from hydrolib.dhydamo.geometry.models import GeometryList


def mesh2d_add_rectilinear(
    network: Network,
    polygon: Union[Polygon, MultiPolygon],
    dx: float,
    dy: float,
    deletemeshoption: int = 1,
) -> None:
    """Add 2d rectilinear mesh to network. A new network is created, clipped, and merged
    with the existing network.

    Args:
        network (Network): Network object to which the mesh is added
        polygon (Union[Polygon, MultiPolygon]): Geometry within which the mesh is generated
        dx (float): Horizontal mesh spacing
        dy (float): Vertical mesh spacing
        deletemeshoption (int, optional): Option for clipping mesh. Defaults to 1.

    Returns:
        _type_: _description_
    """

    # Loop over polygons if a MultiPolygon is given
    plist = common.as_polygon_list(polygon)
    if len(plist) > 1:
        for part in plist:
            mesh2d_add_rectilinear(network, part, dx, dy, deletemeshoption)
        return None

    # Store present 2d mesh (to be able to add)
    existing_mesh2d = network._mesh2d.get_mesh2d()

    # Create new network
    network.mesh2d_create_rectilinear_within_extent(
        extent=polygon.bounds,
        dx=dx,
        dy=dy,
    )

    # Clip and clean
    mesh2d_clip(
        network=network,
        polygon=GeometryList.from_geometry(polygon),
        deletemeshoption=deletemeshoption,
        inside=False,
    )

    # Merge with existing network
    if existing_mesh2d.node_x.size > 0:
        new_mesh2d = network._mesh2d.get_mesh2d()
        # Modify count for indexing variables
        new_mesh2d.edge_nodes += existing_mesh2d.edge_nodes.max() + 1
        new_mesh2d.face_nodes += existing_mesh2d.edge_nodes.max() + 1
        # Add all variables to existing mesh
        variables = [
            "node_x",
            "node_y",
            "edge_nodes",
            "face_nodes",
            "nodes_per_face",
            "edge_x",
            "edge_y",
            "face_x",
            "face_y",
        ]
        for var in variables:
            setattr(
                existing_mesh2d,
                var,
                np.concatenate(
                    [getattr(existing_mesh2d, var), getattr(new_mesh2d, var)]
                ),
            )
        # Process merged mesh
        network._mesh2d._process(existing_mesh2d)


def mesh2d_add_triangular(
    network: Network, polygon: Union[Polygon, MultiPolygon], edge_length: float = None
) -> None:
    """Add triangular mesh to existing network. An orthogonal mesh is generated by the
    meshkernel, which likely means that the given geometry is not completely filled. The
    triangle discretization is determined based on the coordinates on the boundary of the
    provided geometry. Giving an edge_length will discretize the polygon for you, but
    you can also do this yourself.

    Args:
        network (Network): Network object to which the mesh is added
        polygon (Union[Polygon, MultiPolygon]): Geometry within which the mesh is generated
        edge_length (float, optional): Distance for which the polygon boundary is discretized (by approximation). Defaults to None.
    """

    meshkernel = network._mesh2d.meshkernel
    for polygon in common.as_polygon_list(polygon):

        # Interpolate coordinates on polygon with edge_length distance
        if edge_length is not None:
            polygon = common.interp_polygon(polygon, dist=edge_length)

        # Add triangular mesh within polygon
        meshkernel.mesh2d_make_mesh_from_polygon(GeometryList.from_geometry(polygon))

    network._mesh2d._process(network._mesh2d.get_mesh2d())


def mesh2d_clip(
    network: Network,
    polygon: Union[GeometryList, Union[Polygon, MultiPolygon]],
    deletemeshoption: int = 1,
    inside=True,
) -> None:
    """Clip the mesh (currently implemented for 2d) and clean remaining hanging edges.

    Args:
        network (Network): Network for which the mesh is clipped
        polygon (Union[GeometryList, Union[Polygon, MultiPolygon]]): Polygon within which the mesh is clipped
        deletemeshoption (int, optional): Options for deleting nodes inside/outside polygon. Defaults to 1.
        inside (bool, optional): Whether to clip inside or outside the polygon. Defaults to True.
    """

    if isinstance(polygon, GeometryList):
        geo = polygon.to_geometry()
        if not isinstance(geo, (Polygon, MultiPolygon)):
            raise TypeError(
                f"Expected to provided geometrylist to be interpreted as Polygon or MultiPolygon, not a {type(geo)}."
            )
    elif isinstance(polygon, (Polygon, MultiPolygon)):
        polygon = GeometryList.from_geometry(polygon)

    network.mesh2d_clip_mesh(polygon, deletemeshoption, inside)

    # Remove hanging edges
    network._mesh2d.meshkernel.mesh2d_delete_hanging_edges()
    network._mesh2d._process(network._mesh2d.meshkernel.mesh2d_get())


def mesh2d_refine(
    network: Network, polygon: Union[Polygon, MultiPolygon], steps: int
) -> None:
    """Refine mesh 2d within (list of) polygon or multipolygon, with a certain
    number of refinement steps.

    Args:
        network (Network): Network for which the mesh is clipped
        polygon (Union[GeometryList, Union[Polygon, MultiPolygon]]): Polygon within which the mesh is clipped
        steps (int): Number of steps in the refinement
    """
    for polygon in common.as_polygon_list(polygon):
        network.mesh2d_refine_mesh(GeometryList.from_geometry(polygon), level=steps)


def mesh1d_add_branch(
    network: Network,
    branches: Union[
        LineString, MultiLineString, List[Union[LineString, MultiLineString]]
    ],
    node_distance: Union[float, int],
    branch_names: Union[str, List[str]] = None,
    branch_orders: Union[float, int, List[Union[float, int]]] = None,
) -> None:
    """Add branch to 1d mesh, from a (list of) (Multi)LineString geometry.
    The branch is discretized with the given node distance.
    if node distance is given as infinity, no discretization will be performed at mid point of the branch,
    i.e. branch is treated as a pipe

    Args:
        network (Network): Network to which the branch is added
        branches (Union[ LineString, MultiLineString, List[Union[LineString, MultiLineString]] ]): Geometry object(s) for which the branch is created
        node_distance (Union[float, int]): Preferred node distance between branch nodes
        branch_names (Union[str, List[str]]): Branch names to be used in the mesh1d object
        branch_orfers (Union[float, int, List[Union[float, int]]]): Branch orders to be used in the mesh1d object
    """

    if node_distance == np.inf:
        force_midpoint = False
    else:
        force_midpoint = True

    if branch_names is None:
        branch_names = np.repeat(None, len(branches))

    if branch_orders is None:
        branch_orders = np.repeat(-1, len(branches))

    for line, branch_name, branch_order in zip(
        common.as_linestring_list(branches), branch_names, branch_orders
    ):
        branch = Branch(geometry= np.array(round_geometry(line).coords[:])) # avoid error caused by rounding precision
        branch.generate_nodes(node_distance)
        network.mesh1d_add_branch(
            branch,
            name=branch_name,
            branch_order=int(branch_order),
            force_midpoint=force_midpoint,
        )

def round_geometry(geometry, rounding_precision: int = 6):
    """
    Round the coordinates of the geometry object to the provided precision.

    Parameters
    ----------
    geometry
        The geometry object.
    rounding_preicision: int, optional
        Round coordinates to the specified number of digits.
        Defaults to 6.

    Returns
    -------
    A shapely geometry object.
    """
    return loads(dumps(geometry, rounding_precision=rounding_precision))
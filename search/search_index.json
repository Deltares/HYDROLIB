{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HYDROLIB","text":"<p>HYDROLIB is a Python package that is being developed collaboratively, with tools for preprocessing, postprocessing and analysis of hydrodynamical data and simulation results dedicated towards the automation of workflows for hydrological and hydrodynamic modelling. Currently it is focused on (but not restricted to) Delft3D FM (D-HYDRO Suite in Dutch) software for hydrodynamical simulations. HYDROLIB builds upon the basic Delft3D FM I/O functionality provided by the HYDROLIB-core package. HYDROLIB-core is distributed under the MIT License. HYDROLIB is distributed under the LGPL 3.0 license.  </p>"},{"location":"#tools-in-hydrolib","title":"Tools in HYDROLIB","text":"<p>HYDROLIB consist of the following tools:</p> D-HyDAMO modelgenerator from HyDAMO format Profile Optimizer optimizer of 1D profiles Inundation toolbox toolbox for inundation characteristics Case Management tools tools to manage and run cases ARCADIS tools pre- and postprocessing tools HydroMT-Delft3D FM data-adaptor and modelbuilder from global and local data"},{"location":"#more-information","title":"More information","text":"<p>Feel free to contact us at hydrolib@deltares.nl if you want to know more. </p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#041-2025-06-02","title":"0.4.1 (2025-06-02)","text":"<p>This patch release includes fixes to use zonal statistics for the rainfall-runoff section in the D-HyDAMO tool. Zonal statistics does not longer accept extended geodataframes.</p>"},{"location":"changelog/#040-2025-06-02","title":"0.4.0 (2025-06-02)","text":"<p>This release contains improvements and bugfixes for the D-HyDAMO tool. Note that the following release notes are only applicable for the D-HyDAMO tool. </p>"},{"location":"changelog/#general","title":"General","text":"<p>Underlying packages have been updated and the recommended Python version is now 3.12.</p>"},{"location":"changelog/#1d-model","title":"1D model","text":"<ul> <li>weirs with multiple openings and are now treated differently. Whereas formerly the first opening was assigned to the weir, now for every 'extra' opening a fictional weir is created and combined in a compound structure. The same holds for orifices.</li> <li>when pumpstations contain multiple pumps, fictional pumpstations are created and combined in a compound structure. Formerly, in D-HYDRO Suite a pumpstation was created for every pump.</li> <li>related to the former item: pumps in D-HYDRO Suite now inherit the ID of the pumpstation. This used to be the ID of the pump.</li> <li>code to assign order numbers to branches is now contained in one function \"mesh.mesh1d_order_numbers_from_attribute\", where an attribute in the hydamo hydroobjects-file (for example a name) is used to base order numbers on;</li> <li>a CRS-projection is assigned to the net.nc-file and thus the resulting model. For now, only RijksDriehoeksstelsel (EPSG=28992) is supported.</li> <li>the CF-compliance attribute in the net.nc-file has changed to prevent warnings in DHYDRO.</li> <li>functionality to construct storage nodes is added. Waterlevel-area relationships and locations should be provided. Storage nodes can only be located at the location of connection nodes.</li> </ul>"},{"location":"changelog/#2d-model","title":"2D model","text":"<p>There are still two approaches to 2D mesh-generation and 1d2d links: gridgeom and meshkernel. Gridgeom is still available, but meshkernel has been improved significantly and is now able to provide all relevant functionality. - in grid refinement all meshkernel parameters can be passed from D-HyDAMO, providing more control over the resulting - generation of 2d-to-1d links (both embedded and lateral) has been improved; formerly problems ocurred when a rectangular mesh contained triangular cells (for example after mesh refining).</p>"},{"location":"changelog/#rtc-model","title":"RTC model","text":"<ul> <li>bug fix in the parsing of complex structures from XML. It was assumed that the rtcDataConfig-file starts with a reference to the timeseries-file, but this is not necessarily the case (e.g. if no time controllers or controllers with time-varying setpoints are present). Now, the file is also parsed correctly if there is no reference to a timeseries file.</li> </ul>"},{"location":"changelog/#rr-model","title":"RR model","text":"<ul> <li>change in the dropping of nodes with an area of 0 m2. Formerly, in some circumstances, the wrong node ID could be dropped.</li> <li>similar to paved nodes for sewer areas and overflows, specific greenhouses and outlets can be specified, creating extra greenhouse nodes apart from the regular nodes (where one node per catchment was created based on the greenhouse area in the land use map.</li> <li>greenhouse properties (storage per hectare) can now be passed from D-HyDAMO; this used to be hardcoded.</li> <li>the coupling between lateral nodes and catchments was confusing and not completely according the HyDAMO standard. Now, the coupling is created based on the fields globalid (in lateral nodes) and 'lateraleknoopid' in the catchments. However, these ID's are not suitable for the model. For ID's the 'code' attributes of both layers are used. To provide more control over the ID's, the ID's are assigned in the workflow. This was always the case, but the syntax in the workflow is now different (and shorter) than before. </li> </ul>"},{"location":"changelog/#changes-to-the-workflow","title":"Changes to the workflow:","text":"<p>The example workflow has been expanded to illustrate the new functionality above. Furthermore: - examples are included to add all types of structures - examples to add lateral nodes (both constant and timeseries) are added - gridgeom functionality is still available in D-HyDAMO but removed from the notebook. Gridgeom is only usable with additional software that is not freely available. We recommend using meshkernel from now on. - a selection can be made in the notebook whether: 1) all RTC controllers are replaced by timeseries of observed crestlevels/gate heights, for example for calibration, or 2) PID/interval-controllers  are maintained. - the call to 'hydamo.structures.convert.weirs' has been changed: this was not consistent with other calls and now contains named, optional arguments instead of positional arguments. This prevents issues when not all optional input is provided. - Important: the syntax of the coupling between lateral nodes and catchments has been changed. - to add projection information to the model, the funtion 'dimr.add_crs()' is called to post-process the .net file. - the 'sediment' block in the MDU file is removed to prevent errors in DHYDRO.</p>"},{"location":"changelog/#030-2024-09-06","title":"0.3.0 (2024-09-06)","text":""},{"location":"changelog/#020-2023-06-09","title":"0.2.0 (2023-06-09)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>D-HyDAMO: Set branch order to allow interpolation of crosssections</li> <li>D-HyDAMO: Allow creation of compound structures</li> <li>D-HyDAMO: Example notebook with extended demo of new functionalities and custom MDU settings and 2D functionalities</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>D-HyDAMO: Crosssections that are assigned to a structure could (erroneously) also be assigned to a branch</li> </ul>"},{"location":"changelog/#012-2023-01-26","title":"0.1.2 (2023-01-26)","text":""},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>HYDROLIB now depends on hydrolib-core 0.4.1, with the new import structure.</li> </ul>"},{"location":"changelog/#011-2023-01-26","title":"0.1.1 (2023-01-26)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>D-HyDAMO initial version under HYDROLIB package (incl. DAMO 2.2 support and hydrolib-core usage)</li> <li>profile optimizer 0.1.3 (#87)</li> </ul>"},{"location":"HydroLogic_Inundation_Toolbox/","title":"HydroLogic Inundation Toolbox","text":"<p>This module contains readers and tools to extract inundation information (arrival time, maximum rising speed, and water level at maximum rising speed) from the various model output files. </p> <p>HydroLogic Inundation Toolbox is still under development!</p>"},{"location":"HydroLogic_Inundation_Toolbox/#sub-directories","title":"Sub directories","text":"<ul> <li>Data: contains D-HYDRO model output for two example models. The Tol case is provided by HydroLogic, the Zwolle case is by Arcadis (through HYDROLIB).</li> <li>Examples: containts Jupyter notebooks with example usage of the toolbox and readers.</li> <li>Readers: contains flowmeshreader and hisreader.</li> </ul>"},{"location":"HydroLogic_Inundation_Toolbox/#contact","title":"Contact","text":"<p>@Kreef @marcel-ald</p>"},{"location":"Profileoptimizer/","title":"Introduction","text":"<p>The Profile Optimizer is a python tool that automates model optimization for D-Hydro models.  Based on an existing D-HYDRO 1D2D (D-Flow FM) model, a part of the system will be changed to find an optimal situation.  In this version (v0.1.3) it is possible to optimize the bottom width of a single hydroobject (non-branching stream) based on the current bottom level and a chosen slope.  The bottom width is optimised to reach a desired flow velocity at a chosen location. </p> <p>The Profile Optimizer can be adjusted to optimize for other system variables. For example, the slope of the profile or the friction coefficient could be changed.  Other resulting parameters can also be used to test the system, for example the Profile Optimizer could test for an desired water level.  These adjustments are not yet developed. </p>"},{"location":"Profileoptimizer/#usage","title":"Usage","text":"<p>An example workflow is developed in Jupyter Notebook, this notebook explains the possible steps for the profile optimizer.  But to get started with the basics, the principles are also explained here in less detail. </p> <p><pre><code># Initiate profile optimizer class:\nfrom hydrolib.profile_optimizer.optimizer import ProfileOptimizer\nfrom pathlib import Path\n\nbase_model_fn = \"example_folder\"  # should contain MDU of base model\nbat_file = \"example_folder/run.bat\"  # should run DIMR \n\noptimize = ProfileOptimizer(base_model_fn = example_folder, \n                            bat_file = bat_file, \n                            work_dir = Path(\"new_temp_folder\"),  \n                            output_dir: Path(\"new_output_folder\"),\n                            iteration_name='Iteration', \n                            iteration_start_count=1)\n</code></pre> After initiating the class, any number of iterations can be created using the following function: <pre><code>optimize.create_iteration(prof_ids = ['prof_3', 'prof_4', 'prof_5'], \n                          trapezium_pars = dict(bottom_width=4, \n                                                slope_l=2, \n                                                slope_r=1, \n                                                depth=1.5})\n</code></pre> Every call to this function will create a new iteration of the model, written to the work_dir. Another function can be used to run the model, using a copy of the bat_file.  <pre><code>optimize.run_latest()\n</code></pre> The functions to create a search-window for the ideal bottom width are part of <code>hydrolib.profile_optimizer.preprocessing</code>  and are explained in the jupyter notebook. The optimization based on this is based on <code>hydrolib.profile_optimizer.optimizer.find_optimum</code> and is also explained in the jupyter notebook. </p>"},{"location":"Profileoptimizer/#important-notices","title":"Important notices","text":"<p>The base functionality of creating iterations of a D-HYDRO model is covered in <code>optimizer.py</code>'s <code>ProfileOptimizer</code> class.  It is necessary to have a base D-HYDRO model with XY crosssections.  Cross section definitions should be unique to avoid unpredictable behaviour.  For example, if a profile with the definition-id \"default_profile\" is used at multiple locations, and one of these locations is selected in the optimization, the definition will be changed for all locations. </p> <p>In the <code>preprocessing</code> script, some supporting functions are supplied to estimate a reasonable initial bottom width.  These functions are simply guidance, and can be ignored in favor of expert judgement.  The preprocessing functions rely on both the Manning formula and a simple <code>Q=V*A</code>.  The code cannot solve Manning for a chosen Q (discharge), only a chosen V (velocity), for solving B (bottom width). Therefore, the first solve of B is then checked with <code>Q=V*A</code> if the found profile is befitting of the chosen Q.  The first solve of B is then adjusted until it fits with Q.  B is adjusted in steps of 5% until it gets close to Q (default: 5%, can be adjusted by user).  This process can help, but it can also give a wrong indication if the hydraulic system is complex or if the input is not right. </p> <p>Finally: Iterations with asymetric slopes (talud) are possible, but cannot be used as input for preprocessing. </p> <p>TL;DR Warnings:  * Watch out when one profile definition is used at multiple locations  * Preprocessing is only a suggestion, it can be ignored and/or skipped * Asymetric slopes are possible! </p>"},{"location":"Profileoptimizer/#getting-started","title":"Getting Started","text":"<p>The recommended approach to use the Profile Optimizer as a part of the HYDROLIB package.  Please follow the most recent instructions for HYDROLIB (https://github.com/Deltares/HYDROLIB).</p> <p>Alternatively, the following steps can be used to run the Profile Optimizer as a stand-alone package: 1.  Install a conda distribution.  2.  Use conda to install the environment.yml delivered with this project: <code>conda env create --file environment.yml</code>     - the environment is called \"po_env\" and contains all required dependencies, including HYDROLIB-core. 3.  Use the example notebook to use the Profile Optimizer for your model.     - To launch the notebook in this environment, use the following code in anaconda prompt: <code>conda activate profileoptimizer</code> <code>jupyter notebook</code></p>"},{"location":"Profileoptimizer/#contact","title":"Contact","text":"<p>The Profile Optimizer is part of HYDROLIB, an open source community effort for python tools for the hydraulic/hydrological modelling workflows.  For more information about this initiative, visit: https://github.com/Deltares/HYDROLIB</p> <p>The Profile Optimizer is developed by Royal HaskoningDHV: - rineke.hulsman@rhdhv.com - lisa.weijers@rhdhv.com - valerie.demetriades@rhdhv.com</p>"},{"location":"Profileoptimizer/api/","title":"API reference","text":""},{"location":"Profileoptimizer/api/#profile-optimizer","title":"Profile Optimizer","text":"<p>The API references for the Profile Optimizer can be found below:</p> <p>(under construction)</p>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer","title":"<code>ProfileOptimizer</code>","text":"Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>class ProfileOptimizer():\n    def __init__(self, base_model_fn: Path, bat_file, work_dir: Path, output_dir: Path,\n                 iteration_name='Iteration', iteration_start_count=1):\n        \"\"\"Framework for iterative cross-section changes and calculations with DHydro\n\n        The profile optimizer is a class that supplies a framework for running iterative DHydro calculations to optimize\n        a crosssection profile. During the initialization, the base model is copied to the temporary folder (including\n        all files in the parent folder of the base MDU). The base model is read with hydrolib-core and settings are\n        saved to the class to create iterations afterwards.\n\n        Args:\n            base_model_fn: Path to the MDU path of the base model (Pathlib-Path)\n            bat_file: Path to a batch file that runs DIMR (Path or string)\n            work_dir: Path to folder that does not yet exist, where the iterations can be saved temporarily (Pathlib-Path)\n            output_dir: Path to folder that does not yet exist where the final model is saved (Pathlib-Path)\n            iteration_name: Name for the iteration models. Will be used like: \"{iteration_name}_12\" for example (string)\n            iteration_start_count: What should be the first number of the iterations? Default is 1. Can be changed when\n                iterations are run in multiple phases and should be continued.\n\n        Functions:\n            create_iteration: main function, every use of this function creates a new iteration model.\n            run_model: function with which a model can be run using DIMR\n            run_latest: applies run_model, on the most recently created iteration.\n            export_model: using this function will export an iteration (default: last) to the output_dir.\n        \"\"\"\n        self.model_name = base_model_fn.name\n        self.source_folder = base_model_fn.parent\n        self.iteration_nr = iteration_start_count-1\n        self.name = iteration_name\n        self.bat_file = bat_file\n        self._latest_bat = None\n        self.work_dir = Path(work_dir)\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n\n        shutil.copytree(self.source_folder, self.work_dir)\n        self.base_model = FMModel(self.work_dir/self.model_name)\n\n\n    def create_iteration(self, prof_ids: list, trapezium_pars: dict):\n        \"\"\"Creates a new model, changing the profiles and saving it in the temporary folder.\n\n        Creates:\n        - Iteration folder (number is incremental and counted via class)\n        - New crossdef file in iteration folder\n        - New MDU in the upper model folder\n        - DIMR config file in the iteration folder\n        - Batch file in the iteration folder\n\n        Args:\n            prof_ids: list of profiles that should be changed\n            # Caution! if a profile definition is used at multiple locations, this will change the definition for all\n            of those locations!\n            trapezium_pars: dict of the new trapezium profile parameters (bottom_width, slope_l, slope_r, depth)\n\n        Returns:\n            filename to the batch file of this iteration\n        \"\"\"\n        cross_def = pd.DataFrame([cs.__dict__ for cs in self.base_model.geometry.crossdeffile.definition])\n\n        to_change_def = cross_def[cross_def['id'].isin(prof_ids)]\n        bottom_levels = [min(zcoords) for zcoords in to_change_def['zcoordinates']]\n\n        yz = [self._trapezium_coordinates(bl, **trapezium_pars) for bl in bottom_levels]\n\n        cross_def.loc[to_change_def.index, 'ycoordinates'] = pd.Series([y for y, z in yz], index=to_change_def.index)\n        cross_def.loc[to_change_def.index, 'zcoordinates'] = pd.Series([z for y, z in yz], index=to_change_def.index)\n        cross_def.loc[to_change_def.index, 'frictionpositions'] = pd.Series([[0, y[-1]] for y, z in yz],\n                                                                            index=to_change_def.index)\n        cross_def.loc[to_change_def.index, 'yzcount'] = pd.Series([len(y) for y, z in yz], index=to_change_def.index)\n\n        cross_def = cross_def.replace({np.nan: None})\n        crossdef_new = CrossDefModel(definition=cross_def.to_dict(\"records\"))\n\n        self.iteration_nr += 1\n        iteration_name = f'{self.name}_{self.iteration_nr}'\n        iteration_folder = self.work_dir/iteration_name\n        iteration_folder.mkdir(parents=True, exist_ok=True)\n        # write new crossdef to iteration iteration_folder\n        crossdef_name = f'crossdef_{self.iteration_nr}.ini'\n        crossdef_new.save(iteration_folder/crossdef_name)\n        crossdef_new.filepath = Path(f'{iteration_name}/{crossdef_name}')\n        # write new mdu\n        mdu_copy = self.base_model.copy()\n        mdu_copy.geometry.crossdeffile = crossdef_new\n        mdu_copy.filepath = self.work_dir/f'{self.name}_{self.iteration_nr}.mdu'\n        mdu_copy.save(recurse=False)\n        dimr = DIMR()\n        dimr.component.append(FMComponent(name=f'{self.name}_{self.iteration_nr}',\n                                          workingDir=iteration_folder.parent.absolute(),\n                                          inputfile=mdu_copy.filepath.absolute(),\n                                          model=mdu_copy))\n        dimr_fn = iteration_folder/'dimr_config.xml'\n        dimr.save(dimr_fn)\n        with open(dimr_fn, 'r') as f:\n            content = f.readlines()\n        end_documentation_line = [l for l in content if '&lt;/documentation&gt;' in l][0]\n        end_documentation_loc = content.index(end_documentation_line)\n        spaces = end_documentation_line.split('&lt;')[0]\n        content.insert(end_documentation_loc + 1, f'{spaces}&lt;/control&gt;\\n')\n        content.insert(end_documentation_loc + 1, f'{spaces}{spaces}&lt;start name=\"{self.name}_{self.iteration_nr}\" /&gt;\\n')\n        content.insert(end_documentation_loc + 1, f'{spaces}&lt;control&gt;\\n')\n        with open(dimr_fn, 'w+') as f:\n            content_string = ''.join(content)\n            f.write(content_string)\n        self._latest_bat = dimr_fn.parent/'run.bat'\n        shutil.copy(self.bat_file, self._latest_bat)\n        return iteration_folder\n\n    @staticmethod\n    def _trapezium_coordinates(bottom_level, bottom_width, slope_l, slope_r, depth):\n        \"\"\"General function to create y an z coords for a trapezium profile\"\"\"\n        slope_width_l = depth * slope_l\n        slope_width_r = depth * slope_r\n        ycoords = [0, slope_width_r, slope_width_r + bottom_width, slope_width_r + bottom_width + slope_width_l]\n        zcoords = [bottom_level + depth, bottom_level, bottom_level, bottom_level + depth]\n        return ycoords, zcoords\n\n    @staticmethod\n    def run_model(bat_path, model_folder):\n        \"\"\"Runs DIMR for a model of choice\n\n        Args:\n            bat_path: Path to the desired bat file that runs DIMR\n            model_folder: directory where the model is ran\n        \"\"\"\n        print(\"Begin running model\")\n        subprocess.call([str(Path(bat_path).absolute())], cwd=str(Path(model_folder).absolute()))\n        print(\"Done running model\")\n\n    def run_latest(self):\n        \"\"\"Runs DIMR for the most recently made iteration\"\"\"\n        if self._latest_bat is not None:\n            self.run_model(self._latest_bat, self._latest_bat.parent)\n        else:\n            raise ValueError(f'No latest run available. '\n                             f'Use create_iteration() first, or run another model using run_model().')\n\n    def export_model(self, specific_iteration='latest', cleanup=True):\n        \"\"\"Export a model iteration to the output directory.\n\n        Args:\n            specific_iteration: Default: 'latest' will export the last made iteration. Can also be a number-number.\n            cleanup: bool, when True, the temp folder will be deleted afterwards.\n        \"\"\"\n        if specific_iteration == 'latest':\n           iteration = self.iteration_nr\n        else:\n            if type(specific_iteration) is int:\n                iteration = specific_iteration\n            else:\n                raise TypeError(f\"specific_iteration must be an interger or be 'latest'. \"\n                                f\"Input was: {specific_iteration}\")\n\n        mdu_fn = self.work_dir/f\"{self.name}_{iteration}.mdu\"\n        mdu = FMModel(mdu_fn)\n        new_mdu = self.output_dir/f\"{self.model_name.split('.')[0]}_Profile_Optimizer.mdu\"\n        mdu.save(filepath=new_mdu, recurse=True)\n        shutil.copytree(self.work_dir/f\"DFM_OUTPUT_{self.name}_{iteration}\",\n                        self.output_dir/f\"DFM_OUTPUT_{self.model_name.strip('.mdu')}_Profile_Optimizer\")\n\n        other_files = os.listdir(self.work_dir)\n        for filename in other_files:\n            file = self.work_dir/filename\n            if not filename.endswith('.mdu') and not os.path.isfile(file):\n                destination = self.output_dir/Path(file).name\n                if not destination.exists():\n                    shutil.copy(file, destination)\n                    print(f\"Copied {destination.name} to destination\")\n\n        print(f\"Exported iteration {iteration} to output folder as: {new_mdu}\")\n\n        if cleanup:\n            shutil.rmtree(self.work_dir)\n            print(f\"Deleted working directory: {self.work_dir}\")\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer.__init__","title":"<code>__init__(base_model_fn: Path, bat_file, work_dir: Path, output_dir: Path, iteration_name='Iteration', iteration_start_count=1)</code>","text":"<p>Framework for iterative cross-section changes and calculations with DHydro</p> <p>The profile optimizer is a class that supplies a framework for running iterative DHydro calculations to optimize a crosssection profile. During the initialization, the base model is copied to the temporary folder (including all files in the parent folder of the base MDU). The base model is read with hydrolib-core and settings are saved to the class to create iterations afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>base_model_fn</code> <code>Path</code> <p>Path to the MDU path of the base model (Pathlib-Path)</p> required <code>bat_file</code> <p>Path to a batch file that runs DIMR (Path or string)</p> required <code>work_dir</code> <code>Path</code> <p>Path to folder that does not yet exist, where the iterations can be saved temporarily (Pathlib-Path)</p> required <code>output_dir</code> <code>Path</code> <p>Path to folder that does not yet exist where the final model is saved (Pathlib-Path)</p> required <code>iteration_name</code> <p>Name for the iteration models. Will be used like: \"{iteration_name}_12\" for example (string)</p> <code>'Iteration'</code> <code>iteration_start_count</code> <p>What should be the first number of the iterations? Default is 1. Can be changed when iterations are run in multiple phases and should be continued.</p> <code>1</code> <p>Functions:</p> Name Description <code>create_iteration</code> <p>main function, every use of this function creates a new iteration model.</p> <code>run_model</code> <p>function with which a model can be run using DIMR</p> <code>run_latest</code> <p>applies run_model, on the most recently created iteration.</p> <code>export_model</code> <p>using this function will export an iteration (default: last) to the output_dir.</p> Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>def __init__(self, base_model_fn: Path, bat_file, work_dir: Path, output_dir: Path,\n             iteration_name='Iteration', iteration_start_count=1):\n    \"\"\"Framework for iterative cross-section changes and calculations with DHydro\n\n    The profile optimizer is a class that supplies a framework for running iterative DHydro calculations to optimize\n    a crosssection profile. During the initialization, the base model is copied to the temporary folder (including\n    all files in the parent folder of the base MDU). The base model is read with hydrolib-core and settings are\n    saved to the class to create iterations afterwards.\n\n    Args:\n        base_model_fn: Path to the MDU path of the base model (Pathlib-Path)\n        bat_file: Path to a batch file that runs DIMR (Path or string)\n        work_dir: Path to folder that does not yet exist, where the iterations can be saved temporarily (Pathlib-Path)\n        output_dir: Path to folder that does not yet exist where the final model is saved (Pathlib-Path)\n        iteration_name: Name for the iteration models. Will be used like: \"{iteration_name}_12\" for example (string)\n        iteration_start_count: What should be the first number of the iterations? Default is 1. Can be changed when\n            iterations are run in multiple phases and should be continued.\n\n    Functions:\n        create_iteration: main function, every use of this function creates a new iteration model.\n        run_model: function with which a model can be run using DIMR\n        run_latest: applies run_model, on the most recently created iteration.\n        export_model: using this function will export an iteration (default: last) to the output_dir.\n    \"\"\"\n    self.model_name = base_model_fn.name\n    self.source_folder = base_model_fn.parent\n    self.iteration_nr = iteration_start_count-1\n    self.name = iteration_name\n    self.bat_file = bat_file\n    self._latest_bat = None\n    self.work_dir = Path(work_dir)\n    self.output_dir = Path(output_dir)\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n\n    shutil.copytree(self.source_folder, self.work_dir)\n    self.base_model = FMModel(self.work_dir/self.model_name)\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer.create_iteration","title":"<code>create_iteration(prof_ids: list, trapezium_pars: dict)</code>","text":"<p>Creates a new model, changing the profiles and saving it in the temporary folder.</p> <p>Creates: - Iteration folder (number is incremental and counted via class) - New crossdef file in iteration folder - New MDU in the upper model folder - DIMR config file in the iteration folder - Batch file in the iteration folder</p> <p>Parameters:</p> Name Type Description Default <code>prof_ids</code> <code>list</code> <p>list of profiles that should be changed</p> required <code>trapezium_pars</code> <code>dict</code> <p>dict of the new trapezium profile parameters (bottom_width, slope_l, slope_r, depth)</p> required <p>Returns:</p> Type Description <p>filename to the batch file of this iteration</p> Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>def create_iteration(self, prof_ids: list, trapezium_pars: dict):\n    \"\"\"Creates a new model, changing the profiles and saving it in the temporary folder.\n\n    Creates:\n    - Iteration folder (number is incremental and counted via class)\n    - New crossdef file in iteration folder\n    - New MDU in the upper model folder\n    - DIMR config file in the iteration folder\n    - Batch file in the iteration folder\n\n    Args:\n        prof_ids: list of profiles that should be changed\n        # Caution! if a profile definition is used at multiple locations, this will change the definition for all\n        of those locations!\n        trapezium_pars: dict of the new trapezium profile parameters (bottom_width, slope_l, slope_r, depth)\n\n    Returns:\n        filename to the batch file of this iteration\n    \"\"\"\n    cross_def = pd.DataFrame([cs.__dict__ for cs in self.base_model.geometry.crossdeffile.definition])\n\n    to_change_def = cross_def[cross_def['id'].isin(prof_ids)]\n    bottom_levels = [min(zcoords) for zcoords in to_change_def['zcoordinates']]\n\n    yz = [self._trapezium_coordinates(bl, **trapezium_pars) for bl in bottom_levels]\n\n    cross_def.loc[to_change_def.index, 'ycoordinates'] = pd.Series([y for y, z in yz], index=to_change_def.index)\n    cross_def.loc[to_change_def.index, 'zcoordinates'] = pd.Series([z for y, z in yz], index=to_change_def.index)\n    cross_def.loc[to_change_def.index, 'frictionpositions'] = pd.Series([[0, y[-1]] for y, z in yz],\n                                                                        index=to_change_def.index)\n    cross_def.loc[to_change_def.index, 'yzcount'] = pd.Series([len(y) for y, z in yz], index=to_change_def.index)\n\n    cross_def = cross_def.replace({np.nan: None})\n    crossdef_new = CrossDefModel(definition=cross_def.to_dict(\"records\"))\n\n    self.iteration_nr += 1\n    iteration_name = f'{self.name}_{self.iteration_nr}'\n    iteration_folder = self.work_dir/iteration_name\n    iteration_folder.mkdir(parents=True, exist_ok=True)\n    # write new crossdef to iteration iteration_folder\n    crossdef_name = f'crossdef_{self.iteration_nr}.ini'\n    crossdef_new.save(iteration_folder/crossdef_name)\n    crossdef_new.filepath = Path(f'{iteration_name}/{crossdef_name}')\n    # write new mdu\n    mdu_copy = self.base_model.copy()\n    mdu_copy.geometry.crossdeffile = crossdef_new\n    mdu_copy.filepath = self.work_dir/f'{self.name}_{self.iteration_nr}.mdu'\n    mdu_copy.save(recurse=False)\n    dimr = DIMR()\n    dimr.component.append(FMComponent(name=f'{self.name}_{self.iteration_nr}',\n                                      workingDir=iteration_folder.parent.absolute(),\n                                      inputfile=mdu_copy.filepath.absolute(),\n                                      model=mdu_copy))\n    dimr_fn = iteration_folder/'dimr_config.xml'\n    dimr.save(dimr_fn)\n    with open(dimr_fn, 'r') as f:\n        content = f.readlines()\n    end_documentation_line = [l for l in content if '&lt;/documentation&gt;' in l][0]\n    end_documentation_loc = content.index(end_documentation_line)\n    spaces = end_documentation_line.split('&lt;')[0]\n    content.insert(end_documentation_loc + 1, f'{spaces}&lt;/control&gt;\\n')\n    content.insert(end_documentation_loc + 1, f'{spaces}{spaces}&lt;start name=\"{self.name}_{self.iteration_nr}\" /&gt;\\n')\n    content.insert(end_documentation_loc + 1, f'{spaces}&lt;control&gt;\\n')\n    with open(dimr_fn, 'w+') as f:\n        content_string = ''.join(content)\n        f.write(content_string)\n    self._latest_bat = dimr_fn.parent/'run.bat'\n    shutil.copy(self.bat_file, self._latest_bat)\n    return iteration_folder\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer.export_model","title":"<code>export_model(specific_iteration='latest', cleanup=True)</code>","text":"<p>Export a model iteration to the output directory.</p> <p>Parameters:</p> Name Type Description Default <code>specific_iteration</code> <p>Default: 'latest' will export the last made iteration. Can also be a number-number.</p> <code>'latest'</code> <code>cleanup</code> <p>bool, when True, the temp folder will be deleted afterwards.</p> <code>True</code> Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>def export_model(self, specific_iteration='latest', cleanup=True):\n    \"\"\"Export a model iteration to the output directory.\n\n    Args:\n        specific_iteration: Default: 'latest' will export the last made iteration. Can also be a number-number.\n        cleanup: bool, when True, the temp folder will be deleted afterwards.\n    \"\"\"\n    if specific_iteration == 'latest':\n       iteration = self.iteration_nr\n    else:\n        if type(specific_iteration) is int:\n            iteration = specific_iteration\n        else:\n            raise TypeError(f\"specific_iteration must be an interger or be 'latest'. \"\n                            f\"Input was: {specific_iteration}\")\n\n    mdu_fn = self.work_dir/f\"{self.name}_{iteration}.mdu\"\n    mdu = FMModel(mdu_fn)\n    new_mdu = self.output_dir/f\"{self.model_name.split('.')[0]}_Profile_Optimizer.mdu\"\n    mdu.save(filepath=new_mdu, recurse=True)\n    shutil.copytree(self.work_dir/f\"DFM_OUTPUT_{self.name}_{iteration}\",\n                    self.output_dir/f\"DFM_OUTPUT_{self.model_name.strip('.mdu')}_Profile_Optimizer\")\n\n    other_files = os.listdir(self.work_dir)\n    for filename in other_files:\n        file = self.work_dir/filename\n        if not filename.endswith('.mdu') and not os.path.isfile(file):\n            destination = self.output_dir/Path(file).name\n            if not destination.exists():\n                shutil.copy(file, destination)\n                print(f\"Copied {destination.name} to destination\")\n\n    print(f\"Exported iteration {iteration} to output folder as: {new_mdu}\")\n\n    if cleanup:\n        shutil.rmtree(self.work_dir)\n        print(f\"Deleted working directory: {self.work_dir}\")\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer.run_latest","title":"<code>run_latest()</code>","text":"<p>Runs DIMR for the most recently made iteration</p> Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>def run_latest(self):\n    \"\"\"Runs DIMR for the most recently made iteration\"\"\"\n    if self._latest_bat is not None:\n        self.run_model(self._latest_bat, self._latest_bat.parent)\n    else:\n        raise ValueError(f'No latest run available. '\n                         f'Use create_iteration() first, or run another model using run_model().')\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.ProfileOptimizer.run_model","title":"<code>run_model(bat_path, model_folder)</code>  <code>staticmethod</code>","text":"<p>Runs DIMR for a model of choice</p> <p>Parameters:</p> Name Type Description Default <code>bat_path</code> <p>Path to the desired bat file that runs DIMR</p> required <code>model_folder</code> <p>directory where the model is ran</p> required Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>@staticmethod\ndef run_model(bat_path, model_folder):\n    \"\"\"Runs DIMR for a model of choice\n\n    Args:\n        bat_path: Path to the desired bat file that runs DIMR\n        model_folder: directory where the model is ran\n    \"\"\"\n    print(\"Begin running model\")\n    subprocess.call([str(Path(bat_path).absolute())], cwd=str(Path(model_folder).absolute()))\n    print(\"Done running model\")\n</code></pre>"},{"location":"Profileoptimizer/api/#hydrolib.profile_optimizer.profile_optimizer.optimizer.find_optimum","title":"<code>find_optimum(window_b, calculated_v_values, target_v, waterlevel)</code>","text":"<p>A function for the optimization of the bottom width of a trapezoidal cross section profile     for the desired/required flow velocity Args:     window_b: An array of the bottom widths that have been calculated so far in the search window.     calculated_v_values: An array of the calculated flow velocities for the bottom widths in the search window.     target_v: desired flow velocity to achieve in the cross section profile (int).     waterlevel: An array of the calculated water levels. Returns:     df: dataframe with the bottom widths, calculated velocity and the difference between the calculated Velocity         and the target velocity.     optimized_bottom_width: The optimalized bottom width for the desired flow velocity.</p> Source code in <code>hydrolib/profile_optimizer/profile_optimizer/optimizer.py</code> <pre><code>def find_optimum(window_b, calculated_v_values, target_v, waterlevel):\n    \"\"\" A function for the optimization of the bottom width of a trapezoidal cross section profile\n        for the desired/required flow velocity\n    Args:\n        window_b: An array of the bottom widths that have been calculated so far in the search window.\n        calculated_v_values: An array of the calculated flow velocities for the bottom widths in the search window.\n        target_v: desired flow velocity to achieve in the cross section profile (int).\n        waterlevel: An array of the calculated water levels.\n    Returns:\n        df: dataframe with the bottom widths, calculated velocity and the difference between the calculated Velocity\n            and the target velocity.\n        optimized_bottom_width: The optimalized bottom width for the desired flow velocity.\n    \"\"\"\n    lowest_v = min(calculated_v_values)\n    highest_v = max(calculated_v_values)\n    if target_v &lt; lowest_v or target_v &gt; highest_v:\n        print(\"Velocity target is not in the range of the calculated velocities.\\n\"\n              \"Please choose new bottom widths for iterations.\\n\"\n              f\"Target velocity: {target_v}.\\n\"\n              f\"Range of calculated velocities: {lowest_v:.3f} - {highest_v:.3f}.\\n\"\n              f\"Range of input bottom widths: {min(window_b):.3f} - {max(window_b):.3f}\")\n        raise ValueError(\"Velocity target is not in the range of the calculated velocities.\")\n\n    # collect all the relevant data into a dataframe\n    gewenste_u_array = np.ones(len(window_b)) * target_v\n    data = {\"bodembreedte\": window_b, \"berekende stroomsnelheid\": calculated_v_values, \"gewenste stroomsnelheid\": gewenste_u_array, \"berekende waterstand\": waterlevel}\n    df = pd.DataFrame(data=data)\n    df['difference'] = df['berekende stroomsnelheid'] - df['gewenste stroomsnelheid']\n    #print (df)\n\n    # interpolate between the point just above the desired flow_velocity &amp; the point just beneath the desired flow_velocity\n    interpolation_point_u_max = df[(df.difference &gt; 0)].sort_values(ascending=True, by='difference').iloc[0][\n        'berekende stroomsnelheid']\n    interpolation_point_u_min = df[(df.difference &lt; 0)].sort_values(ascending=False, by='difference').iloc[0][\n        'berekende stroomsnelheid']\n    interpolation_point_width_max = df[(df.difference &gt; 0)].sort_values(ascending=True, by='difference').iloc[0][\n        'bodembreedte']\n    interpolation_point_width_min = df[(df.difference &lt; 0)].sort_values(ascending=False, by='difference').iloc[0][\n        'bodembreedte']\n\n\n    gewenste_stroomsnelheid = gewenste_u_array[0]\n    x = [interpolation_point_width_min, interpolation_point_width_max]\n    y = [interpolation_point_u_min, interpolation_point_u_max]\n    optimized_bottom_width = np.interp(gewenste_stroomsnelheid, y, x)\n\n    # plotly figure relatie stroomsnelheid en bodembreedte\n    fig = px.scatter(df, x='bodembreedte', y='berekende stroomsnelheid', text=\"bodembreedte\")\n    fig.update_traces(mode='markers', marker_line_width=2, marker_size=10)\n\n    fig.add_trace(go.Scatter(x=[interpolation_point_width_min, interpolation_point_width_max], y=[interpolation_point_u_min, interpolation_point_u_max], mode='lines', name='ge\u00efnterpoleerde relatie', marker_color='blue'))\n    fig.add_hline(y=gewenste_stroomsnelheid, line_width=1, line_dash='dash', line_color='black')\n    fig.add_hrect(y0=interpolation_point_u_min, y1=interpolation_point_u_max,\n                    fillcolor='grey', opacity=0.2, annotation_text='interpolatie gebied')\n    fig.add_vline(x=optimized_bottom_width, line_width=1, line_dash='dash', line_color='black')\n\n    fig.add_trace(go.Scatter(x=[optimized_bottom_width], y=[gewenste_stroomsnelheid], mode='markers', name='geoptimaliseerde bodembreedte', marker_color='green', marker_line_width=2, marker_size=10))\n    fig.update_yaxes(title_text=\"&lt;b&gt;berekende stroomsnelheid (m/s)&lt;/b&gt;\")\n    # Naming x-axis\n    fig.update_xaxes(title_text=\"&lt;b&gt;bodembreedte (m)&lt;/b&gt;\")\n    fig.update_layout(title=\"&lt;br&gt;Relatie tussen bodembreedte en stroomsnelheid bij het te optimaliseren profiel&lt;/b&gt;\")\n    fig.show()\n\n    # plotly figure relatie stroomsnelheid en bodembreedte en waterlevel\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n    fig.add_trace(go.Scatter(x=df['bodembreedte'], y=df['berekende stroomsnelheid'], name='bodembreedte'), secondary_y=False)\n\n    fig.update_layout(title=\"Relatie tussen bodembreedte, stroomsnelheid en waterlevel bij het te optimaliseren profiel\")\n    fig.add_hline(y=gewenste_stroomsnelheid, line_width=1, line_dash='dash', line_color='black')\n    fig.add_hrect(y0=interpolation_point_u_min, y1=interpolation_point_u_max,\n                    fillcolor='grey', opacity=0.2, annotation_text='interpolatie gebied')\n    fig.add_vline(x=optimized_bottom_width, line_width=1, line_dash='dash', line_color='black')\n\n    fig.add_trace(go.Scatter(x=[optimized_bottom_width], y=[gewenste_stroomsnelheid], mode='markers', name='geoptimaliseerde bodembreedte', marker_color='green', marker_line_width=2, marker_size=10),secondary_y=False)\n\n    #secondary y-axis\n    fig.add_trace(go.Scatter(x=df['bodembreedte'], y=df['berekende waterstand'], name='waterstand'), secondary_y=True)\n    # Naming x-axis\n    fig.update_xaxes(title_text=\"&lt;b&gt;bodembreedte (m)&lt;/b&gt;\")\n\n    # Naming y-axes\n    fig.update_yaxes(title_text=\"&lt;b&gt;berekende stroomsnelheid (m/s)&lt;/b&gt;\", secondary_y=False)\n    fig.update_yaxes(title_text=\"&lt;b&gt;berekende waterstand (m)&lt;/b&gt;\", secondary_y=True)\n    fig.show()\n\n    return df, optimized_bottom_width\n</code></pre>"},{"location":"about/about_HYDROLIB/","title":"HYDROLIB: collaborative development of scripts to automate water system analysis","text":"<p>Hydrological and hydrodynamic simulation models are essential to understand the functioning of a water system, evaluate the impact of possible hazards and assess the impact of adaptation measures. These numerical models are widely used on a national, regional, and urban system scale. The workflows needed to transform data into a simulation model that provide actionable insight is increasingly automated. This automation accelerates the data-to-model process, ensures fit-for-purpose quality of the source data, limits the amount of potential errors, and leads to reproducible models and results. Many organizations see this potential and work towards implementing far-reaching automation in conjunction with hydrological and hydrodynamic simulation software. However, this may lead to a situation where several organizations develop more-or-less similar basic functionality to interact with the same numerical simulation kernel. To this end, a consortium of partners initiated HYDROLIB with the aim to collaboratively develop a software library dedicated to the automation of workflows towards hydrological and hydrodynamic modeling. </p> <p>HYDROLIB is an open community of developers, modelers, and users. It exists of two components. The HYDROLIB-core is the core library of Python wrappers around the Delft3D FM 1D2D (D-HYDRO Suite 1D2D in Dutch) model files (input and output) and model engines (kernel libraries) which is maintained by Deltares. HYDROLIB is a Python package that collects tools for preprocessing, postprocessing and analysis of hydrodynamical data and simulation results. It depends on the tool whether a partner in the HYDROLIB consortium is involved in its maintenance. </p> <p>HYDROLIB was born out of the creation of a TKI (Topconsortium voor Kennis en Innovatie) funded project led by Deltares and in collaboration with 13 organizations. In total 6 consultants, 6 water boards and Wageningen University joined forces with Deltares to establish a toolbox which enables the collaborative development of scripts that focus on automating water system analysis. HYDROLIB-core is distributed under the MIT License. HYDROLIB is distributed under the LGPL 3.0 license.  </p>"},{"location":"about/about_partners/","title":"Partners","text":"<p>HYDROLIB has been made possible by the support and contributions of the following partners:</p> <p> </p>"},{"location":"arcadis/","title":"ARCADIS tools","text":"<p>The ARCADIS tools consist of scripts to change or read D-HYDRO Suite projects.</p> <p>The documentation/scripts are still under construction!</p>"},{"location":"arcadis/#which-scripts-can-be-found-in-this-module","title":"Which scripts can be found in this module?","text":"Script Description Analyse dambreak Analyse results of a calculated dambreak Change_depth_crossections Change the depth of selected cross sections in model. Change friction channels Change the friction of selected branches in model. Change initial channels Change the initial water levels of selected branches in model. Clean D-Hydro Clean D-Hydro model to read into HYDROLIB. Create inundation Create .tif of inundation output. Create observation points channels Create 1D observation points on channels. export_statistics Analyse and export statistics of output. Read dhydro Read several files in D-Hydro (map, his, net, lit, .xyz, .ini) Read &amp; write fixed weirs Read and write fixed weir files. Station points - Voronoi -"},{"location":"arcadis/#contact","title":"Contact","text":"<p>@abuijert @Robbertdelange</p>"},{"location":"case_management_tools/","title":"Case Management Tools","text":"<p>The Case Management Tools developed by D2Hydro include:</p> <ul> <li>Create cases for D-HYDRO Suite</li> <li>Link the StochasticTool of HydroConsult to D-HYDRO Suite 1D2D using HYDROLIB-core </li> <li>Write meteo files of STOWA precipitation stochastics</li> <li>Run D-HYDRO scenarios in parallel</li> <li>Post-process the result on its desired location.</li> </ul> <p>Case Management Tools are still under development!</p>"},{"location":"case_management_tools/#contact","title":"Contact","text":"<p>@d2hydro</p>"},{"location":"dhydamo/","title":"DHyDAMO","text":"<p>DHyDAMO is still under development!</p>"},{"location":"dhydamo/#what-is-dhydamo","title":"What is DHyDAMO?","text":"<p>DHyDAMO provides tools for automatic generation of  Delft3D FM Suite 1D2D models based on HyDAMO DAMO2.2 data.</p> <p>DHyDAMO is an open-source Python package within the Hydrolib environment that enables automatic generation of D-Hydro models  based on a HyDAMO DAMO2.2 dataset.</p>"},{"location":"dhydamo/#why-dhydamo","title":"Why DHyDAMO?","text":"<p>DHyDAMO offers more functionality and flexibility than its predecessor delft3dfmpy. Moreover, coupling to the Hydrolib-core functionality ensures that the interface to D-Hydro remains up to date.</p>"},{"location":"dhydamo/#how-to-use-dhydamo","title":"How to use DHyDAMO?","text":"<p>The DHyDAMO functionality is usable through a JuPyteR notebook. An example is provided in the tutorial.</p>"},{"location":"dhydamo/#more-information","title":"More information","text":"<ul> <li>First users: Installation and tutorial</li> <li>Developers: Reference</li> <li>Current developments: Developments</li> <li>Releases, known issues: to be filled.</li> </ul>"},{"location":"dhydamo/developments/developments/","title":"Developments","text":"<p>DHyDAMO now has the functionality to build a full 1D-2D-RR-RTC model based on HyDAMO DAMO2.2 data. Not all components are yet fully coupled to Hydrolib-core. If hydrolib-core evolves, DHyDAMO will be updated to include more and more hydrolib-core functionality.</p> <p>On the short term, we are working to provide in installation package for DHyDAMO, which will be consistent with other Hydrolib-modules.</p>"},{"location":"dhydamo/getting_started/","title":"Getting started","text":"<p>Installation guide</p> <p>Tutorial</p>"},{"location":"dhydamo/getting_started/installation_guide/","title":"Installation Guide","text":"<p>work-in-progress</p> <p>There is no consistent installation package yet for DHyDAMO. This is in progress. If you are interested in the code, have a look at the Github page.</p> <p>Or, install the package delft3dfmpy. It offers similar (except for RTC) functionality and will eventually be deprecated if DHyDAMO becomes fully available.</p>"},{"location":"dhydamo/getting_started/installation_guide/#prerequisites","title":"Prerequisites","text":"<p>work-in-progress</p>"},{"location":"dhydamo/getting_started/installation_guide/#installation","title":"Installation","text":"<p>work-in-progress</p>"},{"location":"dhydamo/getting_started/installation_guide/#install-dhydamo-in-an-existing-environment","title":"Install DHyDAMO in an existing environment","text":"<p>work-in-progress</p>"},{"location":"dhydamo/getting_started/tutorial/","title":"Example of generating a 1D2DRR model - an overview of functionalities","text":"<p>This notebook gives an overview of the functionalities of the D-HyDAMO module, part of the Hydrolib environment.</p> <p>This notebook is based on previous examples of the python package delft3dfmpy, but now connnected to the Hydrolib-core package, which is used for writing a D-Hydro model. It contains similar functinality as delft3dfmpy v2.0.1; input data is expected to be according to HyDAMO DAMO2.2 gpkg-format. The example model used here is based on a part of the Oostrumsche beek in Limburg, ameded with some fictional dummy data to better illustrate functionalities.</p>"},{"location":"dhydamo/getting_started/tutorial/#load-python-libraries-and-hydrolib-core-functionality","title":"Load Python libraries and Hydrolib-core functionality","text":"<pre><code># Basis\nfrom pathlib import Path\nimport sys\nimport numpy as np\nimport geopandas as gpd\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point, Polygon\nimport matplotlib.pyplot as plt\nimport contextily as cx\nimport os\nimport sys\n</code></pre> <pre><code>## In not installed, add a path from where hydrolib it can be imported\n#sys.path.insert(0, \"d:/Documents/GitHub/HYDROLIB\")\nsys.path.insert(0, \"../../\")\n\n# NOTE: core and dhydamo need to be in the same folder to be imported correctly\n# and from hydrolib-core\nfrom hydrolib.core.io.dimr.models import DIMR, FMComponent\nfrom hydrolib.core.io.inifield.models import IniFieldModel\nfrom hydrolib.core.io.onedfield.models import OneDFieldModel\nfrom hydrolib.core.io.structure.models import *\nfrom hydrolib.core.io.crosssection.models import *\nfrom hydrolib.core.io.ext.models import ExtModel\nfrom hydrolib.core.io.mdu.models import FMModel\nfrom hydrolib.core.io.bc.models import ForcingModel\nfrom hydrolib.core.io.friction.models import FrictionModel\nfrom hydrolib.core.io.obs.models import ObservationPointModel\n\n# Importing relevant classes from Hydrolib-dhydamo\nfrom hydrolib.dhydamo.core.hydamo import HyDAMO\nfrom hydrolib.dhydamo.converters.df2hydrolibmodel import Df2HydrolibModel\nfrom hydrolib.dhydamo.geometry import mesh\nfrom hydrolib.dhydamo.core.drr import DRRModel\nfrom hydrolib.dhydamo.core.drtc import DRTCModel\nfrom hydrolib.dhydamo.io.dimrwriter import DIMRWriter\nfrom hydrolib.dhydamo.io.drrwriter import DRRWriter\nfrom hydrolib.dhydamo.geometry.viz import plot_network\n</code></pre> <p>Define in- and output paths</p> <pre><code># path to the package containing the dummy-data\ndata_path = Path(\"../tests/data\").resolve()\nassert data_path.exists()\n\n# path to write the models\noutput_path = Path(\"../tests/model\").resolve()\n# assert output_path.exists()\n</code></pre> <p>Define components that should be used in the model. 1D is used in all cases.</p> <pre><code>TwoD = True\nRR = True\nRTC = True\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#read-hydamo-damo22-data","title":"Read HyDAMO DAMO2.2 data","text":"<pre><code># all data is contained in one geopackage called 'Example model'\ngpkg_file = str(data_path / \"Example_model.gpkg\")\n\n# initialize a hydamo object\nhydamo = HyDAMO(extent_file=data_path / \"OLO_stroomgebied_incl.maas.shp\")\n\n# show content\nhydamo.branches.show_gpkg(gpkg_file)\n</code></pre> <pre><code>Content of gpkg-file D:\\3640.20\\HYDROLIB-dhydamo\\hydrolib\\tests\\data\\Example_model.gpkg, containing 18 layers:\n    INDEX   |   NAME                            |   GEOM_TYPE       |    NFEATURES  |      NFIELDS\n        0   |   hydroobject                     |   Line String     |           61  |           35\n        1   |   stuw                            |   3D Point        |           25  |           40\n        2   |   duikersifonhevel                |   3D Line String  |           92  |           43\n        3   |   gemaal                          |   3D Point        |            1  |            8\n        4   |   brug                            |   Point           |            1  |           10\n        5   |   pomp                            |   Unknown (any)   |            1  |            9\n        6   |   sturing                         |   Unknown (any)   |            3  |           19\n        7   |   kunstwerkopening                |   Unknown (any)   |          213  |           15\n        8   |   hydrologischerandvoorwaarde     |   Point           |            1  |            8\n        9   |   regelmiddel                     |   3D Point        |           27  |           29\n       10   |   profielpunt                     |   3D Point        |         2203  |           14\n       11   |   ruwheidprofiel                  |   Unknown (any)   |         9976  |           12\n       12   |   afvoergebiedaanvoergebied       |   Unknown (any)   |          121  |            5\n       13   |   lateraleknoop                   |   Point           |          121  |            6\n       14   |   profielgroep                    |   Unknown (any)   |            2  |            4\n       15   |   profiellijn                     |   3D Line String  |            2  |            3\n       16   |   hydroobject_normgp              |   Unknown (any)   |            1  |            4\n       17   |   normgeparamprofielwaarde        |   Unknown (any)   |            7  |            7\n</code></pre> <pre><code># read branchs\nhydamo.branches.read_gpkg_layer(gpkg_file, layer_name=\"HydroObject\", index_col=\"code\")\n# read profiles\nhydamo.profile.read_gpkg_layer(\n    gpkg_file,\n    layer_name=\"ProfielPunt\",\n    groupby_column=\"profiellijnid\",\n    order_column=\"codevolgnummer\",\n    id_col=\"code\",\n)\nhydamo.profile_roughness.read_gpkg_layer(gpkg_file, layer_name=\"RuwheidProfiel\")\nhydamo.profile.snap_to_branch(hydamo.branches, snap_method=\"intersecting\")\nhydamo.profile.dropna(axis=0, inplace=True, subset=[\"branch_offset\"])\nhydamo.profile_line.read_gpkg_layer(gpkg_file, layer_name=\"profiellijn\")\nhydamo.profile_group.read_gpkg_layer(gpkg_file, layer_name=\"profielgroep\")\nhydamo.profile.drop(\"code\", axis=1, inplace=True)\nhydamo.profile[\"code\"] = hydamo.profile[\"profiellijnid\"]\n# structures\nhydamo.culverts.read_gpkg_layer(gpkg_file, layer_name=\"DuikerSifonHevel\", index_col=\"code\")\nhydamo.culverts.snap_to_branch(hydamo.branches, snap_method=\"ends\", maxdist=5)\nhydamo.culverts.dropna(axis=0, inplace=True, subset=[\"branch_offset\"])\n\nhydamo.weirs.read_gpkg_layer(gpkg_file, layer_name=\"Stuw\")\nhydamo.weirs.snap_to_branch(hydamo.branches, snap_method=\"overal\", maxdist=10)\nhydamo.weirs.dropna(axis=0, inplace=True, subset=[\"branch_offset\"])\nhydamo.opening.read_gpkg_layer(gpkg_file, layer_name=\"Kunstwerkopening\")\nhydamo.management_device.read_gpkg_layer(gpkg_file, layer_name=\"Regelmiddel\")\n\nidx = hydamo.management_device[hydamo.management_device[\"duikersifonhevelid\"].notnull()].index\nfor i in idx:\n    globid = hydamo.culverts[\n        hydamo.culverts.code == hydamo.management_device.duikersifonhevelid.loc[i]\n    ].globalid.values[0]\n    hydamo.management_device.at[i, \"duikersifonhevelid\"] = globid\n\nhydamo.pumpstations.read_gpkg_layer(gpkg_file, layer_name=\"Gemaal\", index_col=\"code\")\nhydamo.pumpstations.snap_to_branch(hydamo.branches, snap_method=\"overal\", maxdist=10)\nhydamo.pumps.read_gpkg_layer(gpkg_file, layer_name=\"Pomp\", index_col=\"code\")\nhydamo.management.read_gpkg_layer(gpkg_file, layer_name=\"Sturing\", index_col=\"code\")\n\nhydamo.bridges.read_gpkg_layer(gpkg_file, layer_name=\"Brug\", index_col=\"code\")\nhydamo.bridges.snap_to_branch(hydamo.branches, snap_method=\"overal\", maxdist=1100)\nhydamo.bridges.dropna(axis=0, inplace=True, subset=[\"branch_offset\"])\n# boundaries\nhydamo.boundary_conditions.read_gpkg_layer(\n    gpkg_file, layer_name=\"hydrologischerandvoorwaarde\", index_col=\"code\"\n)\nhydamo.boundary_conditions.snap_to_branch(hydamo.branches, snap_method=\"overal\", maxdist=10)\n\n# catchments\nhydamo.catchments.read_gpkg_layer(gpkg_file, layer_name=\"afvoergebiedaanvoergebied\", index_col=\"code\")\n# laterals\nhydamo.laterals.read_gpkg_layer(gpkg_file, layer_name=\"lateraleknoop\")\nfor ind, cat in hydamo.catchments.iterrows():\n    hydamo.catchments.loc[ind, \"lateraleknoopcode\"] = hydamo.laterals[\n        hydamo.laterals.globalid == cat.lateraleknoopid\n    ].code.values[0]\nhydamo.laterals.snap_to_branch(hydamo.branches, snap_method=\"overal\", maxdist=5000)\n</code></pre> <pre><code>15.0 is MultiPolygon; split into single parts.\n57.0 is MultiPolygon; split into single parts.\n68.0 is MultiPolygon; split into single parts.\n71.0 is MultiPolygon; split into single parts.\n92.0 is MultiPolygon; split into single parts.\n285.0 is MultiPolygon; split into single parts.\n310.0 is MultiPolygon; split into single parts.\n882.0 is MultiPolygon; split into single parts.\n</code></pre> <pre><code>plt.rcParams[\"axes.edgecolor\"] = \"w\"\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\nax.set_xlim(196000, 205000)\nax.set_ylim(391000, 397000)\n\nhydamo.branches.geometry.plot(ax=ax, label=\"Channel\", linewidth=2, color=\"blue\")\nhydamo.profile.geometry.plot(ax=ax, color=\"red\", label=\"Cross section\", linewidth=1)\nhydamo.culverts.geometry.centroid.plot(\n    ax=ax, color=\"yellow\", label=\"Culvert\", markersize=20, zorder=10, marker=\"^\"\n)\nhydamo.weirs.geometry.centroid.plot(ax=ax, color=\"green\", label=\"Weir\", markersize=25, zorder=10, marker=\"^\")\nhydamo.bridges.geometry.plot(ax=ax, color=\"red\", label=\"Bridge\", markersize=20, zorder=10, marker=\"^\")\nhydamo.pumpstations.geometry.plot(\n    ax=ax,\n    color=\"orange\",\n    label=\"Pump\",\n    marker=\"s\",\n    markersize=125,\n    zorder=10,\n    facecolor=\"none\",\n    linewidth=2.5,\n)\nhydamo.boundary_conditions.geometry.plot(\n    ax=ax, color=\"red\", label=\"Boundary\", marker=\"s\", markersize=125, zorder=10, facecolor=\"red\", linewidth=0\n)\nax.legend()\n\ncx.add_basemap(ax, crs=28992, source=cx.providers.OpenStreetMap.Mapnik)\nfig.tight_layout()\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#data-conversion","title":"Data conversion","text":""},{"location":"dhydamo/getting_started/tutorial/#structures","title":"Structures","text":"<p>HyDAMO contains methods to convert HyDAMO2.2 data to internal dataframes, which correspond to the D-Hydro format.</p> <p>We first import the structures from the HyDAMO-object, since the structures' positions are necessary for defining the position of the 1D-mesh. Structures can also be added without the HyDAMO imports. O</p> <p>Note that for importing most structures multiple objects are needed from the GPKG. For more info on how to add structures (directly or from HyDAMO), see: https://hkvconfluence.atlassian.net/wiki/spaces/DHYD/overview.</p> <ul> <li> <p>for weirs, a corresponding profile is looked up in the crossections. If one is found, the weir is implemented as a universal weir. If it is not found, a regular (rectangular) weir will be used. The cross-section ('hydamo.profile') should be related through 'hydamo.profile_line' to a 'hydamo.profile_group', which contains a 'stuwid' column which is equal to the GlobalID of the corresponding weir. The weir object can also include orifices, in that case the field 'overlaatonderlaat' in the 'management_device-object ('regelmiddel') is 'onderlaat'. For weirs it should be 'overlaat'.</p> </li> <li> <p>for culverts, a regelmiddel can be used to model a 'schuif' and/or a 'terugslagklep'. This is specified by the field 'soortregelmiddel'. In case of a 'terugslagklep', the flow direction is set to 'positive' instead of 'both'. In case of a 'schuif', a valve is implemented. Note that in DAMO2.2, an 'afsluitmiddel' can contain the same information. For now, only a regelmiddel (management_device) is implemented. In a next version, the flexibility to use both will be included. </p> </li> <li> <p>bridges need an associated crosssection. This is idential to universal weirs, but here the 'hydamo.profile_group'-object should contain a field 'brugid'. </p> </li> <li> <p>pumps are composed from 'hydamo.pumpstations', 'hydamo.pumps' and 'hydamo.managmement'. Only suction-side drection is implemented. Maximal capacity should be in m3/min.</p> </li> </ul> <p>In most cases, these 'extra' arguments are optional, i.e. they are not required and can be left out. Some are required: - pumps really need all 3 objects ('hydamo.pumpstations', 'hydamo.pumps' and 'hydamo.managmement'); - bridges really need an associated crosssection (see above);</p> <p>For more info on the structure definitions one is referred to the D-Flow FM user manual: https://content.oss.deltares.nl/delft3d/manuals/D-Flow_FM_User_Manual.pdf.</p> <pre><code>hydamo.structures.convert.weirs(\n    hydamo.weirs,\n    hydamo.profile_group,\n    hydamo.profile_line,\n    hydamo.profile,\n    hydamo.opening,\n    hydamo.management_device,\n)\n\nhydamo.structures.convert.culverts(hydamo.culverts, management_device=hydamo.management_device)\n\nhydamo.structures.convert.bridges(\n    hydamo.bridges,\n    profile_groups=hydamo.profile_group,\n    profile_lines=hydamo.profile_line,\n    profiles=hydamo.profile,\n)\n\nhydamo.structures.convert.pumps(hydamo.pumpstations, pumps=hydamo.pumps, management=hydamo.management)\n</code></pre> <p>Additional methods are available to add structures:</p> <pre><code>hydamo.structures.add_rweir(\n    id=\"rwtest\",\n    name=\"rwtest\",\n    branchid=\"W_1386_0\",\n    chainage=2.0,\n    crestlevel=18.0,\n    crestwidth=3.0,\n    corrcoeff=1.0,\n)\n</code></pre> <p>The resulting dataframes look like this:</p> <pre><code>hydamo.structures.culverts_df.head()\n</code></pre> id name branchid chainage rightlevel leftlevel length inletlosscoeff outletlosscoeff csdefid bedfrictiontype bedfriction allowedflowdir valveonoff numlosscoeff valveopeningheight relopening losscoeff 0 B_11954 None W_2591_1 895.235 11.891157 11.891157 2.834944 0.5 1.0 B_11954 Manning 0.01667 both 0 None 0.0 None None 1 B_11547 None W_242225_0 158.537 12.736937 12.736937 0.953823 0.5 1.0 B_11547 Manning 0.01667 both 0 None 0.0 None None 2 B_11546 None W_242226_0 0.244 12.335174 12.335174 1.485853 0.5 1.0 B_11546 Manning 0.01667 both 0 None 0.0 None None 3 B_11544 None W_242224_0 775.644 13.107891 13.107891 2.610899 0.5 1.0 B_11544 Manning 0.01667 both 0 None 0.0 None None 4 B_11548 None W_242227_0 8.699 11.781898 11.781898 4.115577 0.5 1.0 B_11548 Manning 0.01667 both 0 None 0.0 None None"},{"location":"dhydamo/getting_started/tutorial/#initialize-the-fm-model","title":"Initialize the FM-model","text":"<p>At this stage also the start and stoptime are defined, they will be used in the other modules if needed</p> <pre><code>fm = FMModel()\n# Set start and stop time\nfm.time.refdate = 20160601\nfm.time.tstop = 2 * 3600 * 24\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#add-the-1d-mesh","title":"Add the 1D mesh","text":"<p>The above structures are collected in one dataframe and in the generation of calculation poins, as structures should be separated by calculation points.</p> <pre><code>structures = hydamo.structures.as_dataframe(\n    rweirs=True,\n    bridges=True,\n    uweirs=True,\n    culverts=True,\n    orifices=True,\n    pumps=True,\n)\n</code></pre> <pre><code>mesh.mesh1d_add_branches_from_gdf(\n    fm.geometry.netfile.network,\n    branches=hydamo.branches,\n    branch_name_col=\"code\",\n    node_distance=20,\n    max_dist_to_struc=None,\n    structures=structures,\n)\n</code></pre> <pre><code>Some structures are not linked to a branch.\nStructures [22, 25] have the same location.\nStructures [19, 28] have the same location.\nStructures [27, 33] have the same location.\n</code></pre> <p>Add cross-sections to the branches. TO do this, many HyDAMO objects might be needed: if parameterised profiles occur, they are taken from hydamo.param_profile and, param_profile_values; if crosssections are associated with structures, those are specified in profile_group and profile lines. </p> <p>HyDAMO DAMO2.2 data contains two roughness values (high and low); here it can be specified which one to use.</p> <p>For branches without a crosssection, a default profile can be defined.</p> <pre><code>hydamo.crosssections.convert.profiles(\n    crosssections=hydamo.profile,\n    crosssection_roughness=hydamo.profile_roughness,\n    profile_groups=hydamo.profile_group,\n    profile_lines=hydamo.profile_line,\n    param_profile=hydamo.param_profile,\n    param_profile_values=hydamo.param_profile_values,\n    branches=hydamo.branches,\n    roughness_variant=\"High\",\n)\n\n# Set a default cross section\ndefault = hydamo.crosssections.add_rectangle_definition(\n    height=5.0, width=5.0, closed=False, roughnesstype=\"StricklerKs\", roughnessvalue=30, name=\"default\"\n)\nhydamo.crosssections.set_default_definition(definition=default, shift=10.0)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#observation-points","title":"Observation points","text":"<p>Observation points are now written in the new format, where once can discriminate between 1D ('1d') and 2D ('2d') observation points. This can be done using the optional argument 'locationTypes'. If it is omitted, all points are assumed to be 1d. 1D-points are always snapped to a the nearest branch. 2D-observation points are always defined by their X/Y-coordinates.</p> <p>Note: add_points can be called only once: once dfmodel.observation_points is filled,the add_points-method is not available anymore. Observation point coordinates can be definied eiher as an (x,y)-tuple or as a shapely Point-object.</p> <pre><code>hydamo.observationpoints.add_points(\n    [Point((200200, 395600)), (200200, 396200)],\n    [\"ObsPt1\", \"ObsPt2\"],\n    locationTypes=[\"1d\", \"1d\"],\n    snap_distance=10.0,\n)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#storage-nodes","title":"Storage nodes","text":"<pre><code>hydamo.storagenodes.add_storagenode(\n    \"test\",\n    \"123_123\",\n    usestreetstorage=\"true\",\n    nodetype=\"unspecified\",\n    name=np.nan,\n    usetable=\"false\",\n    bedlevel=12.0,\n    area=100,\n    streetlevel=14.0,\n    streetstoragearea=10.0,\n    storagetype=\"reservoir\",\n    levels=np.nan,\n    storagearea=np.nan,\n    interpolate=\"linear\",\n)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#boundary-conditions","title":"Boundary conditions","text":"<pre><code>hydamo.external_forcings.convert.boundaries(hydamo.boundary_conditions, mesh1d=fm.geometry.netfile.network)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#add-a-fictional-time-series-to-use-in-the-bc-file","title":"Add a fictional time series to use in the BC file","text":"<pre><code>series = pd.Series(np.sin(np.linspace(2, 8, 120) * -1) + 1.0)\nseries.index = [pd.Timestamp(\"2016-06-01 00:00:00\") + pd.Timedelta(hours=i) for i in range(120)]\nseries.plot()\n</code></pre> <pre><code>&lt;AxesSubplot:&gt;\n</code></pre> <p>There is also a fuction to convert laterals, but to run this we also need the RR model. Therefore, see below. It also possible to manually add boundaries and laterals as constants or timeseries. We implement the sinoid above as an upstream streamflow boundary and a lateral:</p> <pre><code>hydamo.external_forcings.add_boundary_condition(\n    \"RVW_01\", (197464.0, 392130.0), \"dischargebnd\", series, fm.geometry.netfile.network\n)\n</code></pre> <pre><code>hydamo.dict_to_dataframe(hydamo.external_forcings.boundary_nodes)\n</code></pre> id quantity value time time_unit value_unit nodeid RVM_02 RVM_02 waterlevelbnd 11.0 None minutes since 0000-00-00 00:00:00 m 201414.562000_396649.200000 RVW_01 RVW_01 dischargebnd [0.09070257317431829, 0.11283143771052084, 0.1... [0.0, 60.0, 120.0, 180.0, 240.0, 300.0, 360.0,... minutes since 2016-06-01 00:00:00 m3/s 197462.792000_392131.096000"},{"location":"dhydamo/getting_started/tutorial/#initial-conditions","title":"Initial conditions","text":"<p>Set the initial water depth to 0.5 m. It is also possible to set a global water level using the equivalent function \"set_initial_waterlevel\".</p> <pre><code>hydamo.external_forcings.set_initial_waterdepth(1.5)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#2d-mesh","title":"2D mesh","text":"<p>To add a mesh, currently 2 options exist: 1. The converter can generate a relatively simple mesh, with a rotation or refinement. Note that rotation and refinement is currently not possible. In the section below we generate a refined 2D mesh with the following steps:</p> <pre><code>- Generate grid within a polygon. The polygon is the extent given to the HyDAMO model.\n- Refine along the main branch\n- Determine altitude from a DEM.\n</code></pre> <pre><code># 2d mesh extent\nif TwoD:\n    extent = gpd.read_file(r\"..\\tests\\data\\2D_extent.shp\").at[0, \"geometry\"]\n    network = fm.geometry.netfile.network\n</code></pre> <p>To generate a triangular mesh:</p> <pre><code>#if TwoD:\n    #mesh.mesh2d_add_triangular(network, extent, edge_length=50.0)\n</code></pre> <p>And a rectangular mesh:</p> <pre><code>if TwoD:\n    mesh.mesh2d_add_rectilinear(network, extent, dx=50, dy=50)\n</code></pre> <pre><code>if TwoD:\n    print(\"Nodes before refinement:\", network._mesh2d.mesh2d_node_x.size)\n\n    # refine around the branches. This does only work for a polygon without holes, so use the exterior\n    buffer = Polygon(hydamo.branches.buffer(50.0).union_all().exterior)\n    mesh.mesh2d_refine(network, buffer, 1)\n    print(\"Nodes after refinement:\", network._mesh2d.mesh2d_node_x.size)\n\n    # add terrain level\n    mesh.mesh2d_altitude_from_raster(network, \"../tests/data/rasters/AHN_2m_clipped_filled.tif\", \"face\", \"mean\", fill_value=-999)\n</code></pre> <pre><code>Nodes before refinement: 7515\nNodes after refinement: 11945\n</code></pre> <p>For linking the 1D and 2D model, three options are available: 1. Generating links from each 1d node to the nearest 2d node. 2. Generating links from each 2d node to the nearest 1d node (intersecting==True) 3. Generating links from each 2d node to the nearest 1d node, while not allowing the links to intersect other cells (intersecting==True).</p> <p>Intersecting indicates whether or not the 2D cells cross the 1D network (lateral versus embedded links). So, option 3 is relevant when there is no 2d mesh on top of the 1d mesh: the lateral links.</p> <p>Note that for each option a maximum link length can be chosen, to prevent creating long (and perhaps unrealistic) links.</p>"},{"location":"dhydamo/getting_started/tutorial/#add-1d-2d-links","title":"Add 1d-2d links","text":"<pre><code>if TwoD:\n    mesh.links1d2d_add_links_1d_to_2d(fm.geometry.netfile.network)\n</code></pre> <pre><code>if TwoD:\n    network = fm.geometry.netfile.network\n    fig, axs = plt.subplots(figsize=(13.5, 6), ncols=2, constrained_layout=True)\n    plot_network(network, ax=axs[0])\n    plot_network(network, ax=axs[1], links1d2d_kwargs=dict(lw=3, color=\"k\"))\n    for ax in axs:\n        ax.set_aspect(1.0)\n        ax.plot(*buffer.exterior.coords.xy, color=\"k\", lw=0.5)\n    axs[0].autoscale_view()\n    axs[1].set_xlim(199700, 200200)\n    axs[1].set_ylim(393600, 394100)\n\n    sc = axs[1].scatter(\n        x=network._mesh2d.mesh2d_face_x,\n        y=network._mesh2d.mesh2d_face_y,\n        c=network._mesh2d.mesh2d_face_z,\n        s=10,\n        vmin=17,\n        vmax=20,\n    )\n    cb = plt.colorbar(sc, ax=axs[1])\n    cb.set_label(\"Face level [m+NAP]\")\n\n    plt.show()\n</code></pre> <p>For finalizing the FM-model, we also need the coupling to the other modules. Therefore, we will do that first.</p>"},{"location":"dhydamo/getting_started/tutorial/#add-an-rtc-model","title":"Add an RTC model","text":"<p>RTC contains many different options. Three are now implemented in D-HyDAMO:  - a PID controller (crest level is determined by water level at an observation point); - a time controller (a time series of crest level is provided); - the possibility for the users to provide their own XML-files for more complex cases. Depending on the complexity, the integration might not yet work for all cases.</p> <p>First, initialize a DRTCModel-object. The input is hydamo (for the data), fm (for the time settings), a path where the model will be created (typically an 'rtc' subfolder), a timestep (default 60 seconds) and, optionally, a folder where the user can put 'custom' XML code that will be integrated in the RTC-model. These files will be parsed now and be integrated later.</p> <pre><code>if RTC:\n    drtcmodel = DRTCModel(\n        hydamo,\n        fm,\n        output_path=output_path,\n        rtc_timestep=60.0,\n        complex_controllers_folder=data_path / \"complex_controllers\"        \n    )\n</code></pre> <p>If PID controllers are present, they need settings that are not included in the HyDAMO DAMO2.2 data. We define those in a dictionary. They can be specified for each structure - in that case the key of the dictionary should match the key in the HyDAMO DAMO2.2 'sturing'-object. If no separate settings are provided the 'global' settings are used.</p> <pre><code>if RTC:\n    pid_settings = {}\n    pid_settings[\"global\"] = {\n        \"ki\": -0.05,\n        \"kp\": -0.03,\n        \"kd\": 0.0,\n        \"maxspeed\": 0.00033,\n    }\n    pid_settings[\"kst_pid\"] = {\n            \"ki\": -0.03,\n            \"kp\": -0.0,\n            \"kd\": 0.0,\n            \"maxspeed\": 0.00033,\n        }\n</code></pre> <p>The function 'from_hydamo' converts the controllers that are specified in the HyDAMO DAMO2.2 data. The extra input consists of the settings for PID controllers (see above) and a dataframe with time series for the time controllers.</p> <pre><code>if RTC:\n    if not hydamo.management.typecontroller.empty:\n        timeseries = pd.read_csv(data_path / \"timecontrollers.csv\")\n        timeseries.index = timeseries.Time        \n\n        drtcmodel.from_hydamo(pid_settings=pid_settings, timeseries=timeseries)\n</code></pre> <p>Additional controllers, that are not included in D-HyDAMO DAMO2.2 might be specified like this:</p> <pre><code>if RTC:\n    drtcmodel.add_pid_controller(\n        structure_id=\"S_96788\",\n        steering_variable=\"Crest level (s)\",\n        target_variable=\"Water level (op)\",\n        setpoint=18.2,\n        observation_location=\"ObsPt2\",\n        lower_bound=18.0,\n        upper_bound=18.4,\n        pid_settings=pid_settings[\"global\"],\n    )\n\n    drtcmodel.add_time_controller(\n        structure_id=\"S_96548\", steering_variable=\"Crest level (s)\", data=timeseries.iloc[:,1]\n    )\n</code></pre> <p>Note that the provided complex controllers use observation points that are not yet in the model. As opposed to delft3dfmpy, it is now possible to add observation points in stages. So we add the missing point now:</p> <pre><code>hydamo.observationpoints.add_points(\n    [Point(199423, 393755), Point(200260, 393771)],\n    [\"ObsPt3\", \"ObsPt4\"],\n    locationTypes=[\"1d\", \"1d\"],\n    snap_distance=20.0,\n)\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#add-a-rainfall-runoff-model","title":"Add a rainfall runoff model","text":"<p>RR has not changed yet compared to delft3dfmpy. Initialize a model:</p> <pre><code>if RR:\n    drrmodel = DRRModel()\n</code></pre> <p>Catchments are provided in the HyDAMO DAMO2.2 format and included in the GPKG. They can also be read from other formats using 'read_gml', or 'read_shp'. Note that in case of shapefiles column mapping is necessary because the column names are truncated. </p> <p>Note that when catchments have a \"MultiPolygon' geometry, the multipolygons are 'exploded' into single polygon geometries. A warning of this is isued, and a suffix is added to every polygons ID to prevent duplicates. </p> <p>For every catchment, the land use areas will be calculated and if appopriate a maximum of four RR-nodes will be created per catchment:  - unpaved (based on the Ernst concept)  - paved   - greenhouse  - open water (not the full Sobek2 open water, but only used to transfer (net) precipitation that falls on open water that is schematized in RR to the 1D/2D network.</p> <p>At the moment, two options exist for the schematisation of the paved area:  1) simple: the paved fraction of each catchment is modelled with a paved node, directly connected to catchments' boundary node    2) more complex: sewer area polygons and overflow points are used a input as well. For each sewer area, the overlapping paved area is the distributed over the overflows that are associated with the sewerarea (the column 'lateraleknoopcode') using the area fraction (column 'fractie') for each overflow. In each catchment, paved area that does not intersect with a sewer area gets an unpaved node as in option (1).</p> <p>Load data and settings (still to fill with documentatation from delft3dfmpy)</p> <pre><code>if RR:\n    # all data and settings to create the RR-model\n    lu_file = data_path / \"rasters\" / \"sobek_landuse.tif\"\n    ahn_file = data_path / \"rasters\" / \"AHN_2m_clipped_filled.tif\"\n    soil_file = data_path / \"rasters\" / \"sobek_soil.tif\"\n    surface_storage = 10.0\n    infiltration_capacity = 100.0\n    initial_gwd = 1.2  # water level depth below surface\n\n    runoff_resistance = 1.0\n    infil_resistance = 300.0\n    layer_depths = [0.0, 1.0, 2.0]\n    layer_resistances = [30, 200, 10000]\n    street_storage = 10.0\n    sewer_storage = 10.0\n    pumpcapacity = 10.0\n    roof_storage = 10.0\n    meteo_areas = hydamo.catchments\n</code></pre> <p>Fill the nodes:</p> <p>For land use and soil type a coding is prescribed. For landuse, the legend of the map is expected to be as follows:   1 potatoes    2 wheat  3 sugar beet   4 corn          5 other crops    6 bulbous plants   7 orchard  8 grass    9 deciduous forest   10 coniferous forest 11 nature 12 barren 13 open water 14 built-up 15 greenhouses</p> <p>For classes 1-12, the areas are calculated from the provided raster and remapped to the classification in the Sobek RR-tables.</p> <p>The coding for the soil types: 1 'Veengrond met veraarde bovengrond'  2 'Veengrond met veraarde bovengrond, zand'  3 'Veengrond met kleidek'  4 'Veengrond met kleidek op zand'  5 'Veengrond met zanddek op zand'  6 'Veengrond op ongerijpte klei'  7 'Stuifzand'  8 'Podzol (Leemarm, fijn zand)'  9 'Podzol (zwak lemig, fijn zand)' 10 'Podzol (zwak lemig, fijn zand op grof zand)' 11 'Podzol (lemig keileem)' 12 'Enkeerd (zwak lemig, fijn zand)' 13 'Beekeerd (lemig fijn zand)' 14 'Podzol (grof zand)' 15 'Zavel' 16 'Lichte klei' 17 'Zware klei' 18 'Klei op veen' 19 'Klei op zand' 20 'Klei op grof zand' 21 'Leem'</p> <p>And surface elevation needs to be in m+NAP.</p> <pre><code>if RR:\n    drrmodel.unpaved.io.unpaved_from_input(\n        hydamo.catchments,\n        lu_file,\n        ahn_file,\n        soil_file,\n        surface_storage,\n        infiltration_capacity,\n        initial_gwd,\n        meteo_areas,\n    )\n    drrmodel.unpaved.io.ernst_from_input(\n        hydamo.catchments,\n        depths=layer_depths,\n        resistance=layer_resistances,\n        infiltration_resistance=infil_resistance,\n        runoff_resistance=runoff_resistance,\n    )\n    drrmodel.paved.io.paved_from_input(\n        catchments=hydamo.catchments,\n        landuse=lu_file,\n        surface_level=ahn_file,\n        street_storage=street_storage,\n        sewer_storage=sewer_storage,\n        pump_capacity=pumpcapacity,\n        meteo_areas=meteo_areas,\n        zonalstats_alltouched=True,\n    )\n    drrmodel.greenhouse.io.greenhouse_from_input(\n        hydamo.catchments, lu_file, ahn_file, roof_storage, meteo_areas, zonalstats_alltouched=True\n    )\n    drrmodel.openwater.io.openwater_from_input(\n        hydamo.catchments, lu_file, meteo_areas, zonalstats_alltouched=True\n    )\n</code></pre> <p>Make the RR boundaries:</p> <pre><code>if RR:\n    drrmodel.external_forcings.io.boundary_from_input(hydamo.laterals, hydamo.catchments, drrmodel)\n</code></pre> <p>Again, the result is a dictionary, but it can be easily displayed as a dataframe:</p> <pre><code>if RR:\n    hydamo.dict_to_dataframe(drrmodel.paved.pav_nodes).tail()\n</code></pre> <p>As with FM objects, also RR-nodes can be added from the workflow. An unpaved node as an example:</p> <pre><code>if RR:\n    drrmodel.paved.add_paved(\n        id=\"test_pav\",\n        area=\"100\",\n        surface_level=\"18.1\",\n        street_storage=\"10.0\",\n        sewer_storage=\"10.0\",\n        pump_capacity=\"1.\",\n        meteo_area=hydamo.catchments.iloc[0].code,\n        px=str(hydamo.catchments.iloc[0].geometry.centroid.coords[0][0]),\n        py=str(hydamo.catchments.iloc[0].geometry.centroid.coords[0][1]),\n        boundary_node=list(drrmodel.external_forcings.boundary_nodes.keys())[0],\n    )\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#external-forcings","title":"External forcings","text":"<p>Three types of external forcing need to be provided: - Seepage/drainage - Precipitation - Evaporation</p> <p>All are assumed to be spatially variable and thus need to pe provided as rasters per time step. Only the locations of the folders containing the rasters need to be provided; the time step is then derived from the file names.</p> <p>Precipitation and evaporation are assumed to be in mm/d. As for evaporation only one meteostation is used, the meteo_areas are dissolved. For seepage, as the use of Metaswap-rasters is allowed, the unit is assumed to m3/grid cell/timestep.</p> <p>Rastertypes can be any type that is recognized by rasterio (in any case Geotiff and ArcASCII rasters). If the file extension is 'IDF', as is the case in Modflow output, the raster is read using the 'imod'-package.</p> <p>IMPORTANT: time steps are extracted from the file names. Therefore, the names should cohere to some conditions: The filename should consist of at least two parts, separated by underscores. The second part needs to contain time information, which should be formatted as YYYYMMDDHHMMSS (SS may be omitted). Or, for daily data YYYYMMDD.</p> <p>For example: 'precip_20200605151500.tif'</p> <p>Extracting meteo-data from rasters can be time consuming. If precip_file and evap_file are specified, meteo-files are copied from an existing location.</p> <pre><code>if RR:\n    seepage_folder = data_path / \"rasters\" / \"seepage\"\n    precip_file = str(data_path / \"DEFAULT.BUI\")\n    evap_folder = data_path / \"rasters\" / \"evaporation\"\n    drrmodel.external_forcings.io.seepage_from_input(hydamo.catchments, seepage_folder)\n    drrmodel.external_forcings.io.precip_from_input(meteo_areas, precip_folder=None, precip_file=precip_file)\n    drrmodel.external_forcings.io.evap_from_input(meteo_areas, evap_folder=evap_folder, evap_file=None)\n</code></pre> <pre><code>Reading seepage files:   0%|          | 0/3 [00:00&lt;?, ?it/s]\n\n\n\nReading evaporation files:   0%|          | 0/3 [00:00&lt;?, ?it/s]\n</code></pre> <p>Add the main parameters:</p> <pre><code>if RR:   \n    drrmodel.d3b_parameters[\"Timestepsize\"] = 300\n    drrmodel.d3b_parameters[\"StartTime\"] = \"'2016/06/01;00:00:00'\"  # should be equal to refdate for D-HYDRO\n    drrmodel.d3b_parameters[\"EndTime\"] = \"'2016/06/03;00:00:00'\"\n    drrmodel.d3b_parameters[\"RestartIn\"] = 0\n    drrmodel.d3b_parameters[\"RestartOut\"] = 0\n    drrmodel.d3b_parameters[\"RestartFileNamePrefix\"] = \"Test\"\n    drrmodel.d3b_parameters[\"UnsaturatedZone\"] = 1\n    drrmodel.d3b_parameters[\"UnpavedPercolationLikeSobek213\"] = -1\n    drrmodel.d3b_parameters[\"VolumeCheckFactorToCF\"] = 100000\n</code></pre> <p>And now we can also add the laterals to FM with the correct settings:</p> <pre><code>if RR:\n    hydamo.external_forcings.convert.laterals(\n        hydamo.laterals,\n        lateral_discharges=None,\n        rr_boundaries=drrmodel.external_forcings.boundary_nodes,\n    )\nelse:\n    lateral_discharges = hydamo.laterals[\"afvoer\"]\n    lateral_discharges.index = hydamo.laterals.code\n    hydamo.external_forcings.convert.laterals(\n        hydamo.laterals, lateral_discharges=lateral_discharges, rr_boundaries=None\n    )\n</code></pre> <p>And now we can also manually add lateral nodes, which we still need to convert to a dataframe.</p> <pre><code>if not RR:\n    hydamo.external_forcings.add_lateral(\"LAT_01\", \"W_242209_0\", \"5.0\", series)\n    hydamo.dict_to_dataframe(hydamo.external_forcings.lateral_nodes).tail()\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#plot-the-rr-model","title":"Plot the RR model","text":"<pre><code>def node_geometry(dict):\n    # Function to put the node geometries in geodataframes\n    from shapely.geometry import Point, LineString\n\n    geoms = []\n    links = []\n    for i in dict.items():\n        if \"ar\" in i[1]:\n            if np.sum([float(s) for s in i[1][\"ar\"].split(\" \")]) &gt; 0:\n                geoms.append(Point((float(i[1][\"px\"]), float(i[1][\"py\"]))))\n                links.append(\n                    LineString(\n                        (\n                            Point(float(i[1][\"px\"]), float(i[1][\"py\"])),\n                            Point(\n                                float(drrmodel.external_forcings.boundary_nodes[i[1][\"boundary_node\"]][\"px\"]),\n                                float(drrmodel.external_forcings.boundary_nodes[i[1][\"boundary_node\"]][\"py\"]),\n                            ),\n                        )\n                    )\n                )\n        else:\n            geoms.append(Point((float(i[1][\"px\"]), float(i[1][\"py\"]))))\n    return ((gpd.GeoDataFrame(geoms, columns=[\"geometry\"])), gpd.GeoDataFrame(links, columns=[\"geometry\"]))\n</code></pre> <pre><code>## plt.rcParams['axes.edgecolor'] = 'w'\nimport matplotlib.patches as mpatches\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\nax.xaxis.set_visible(False)\nax.yaxis.set_visible(False)\nax.set_xlim(195000, 205000)\nax.set_ylim(390000, 399000)\n\nhydamo.catchments.geometry.plot(ax=ax, label=\"Catchments\", edgecolor=\"black\", facecolor=\"pink\", alpha=0.5)\nhydamo.branches.geometry.plot(ax=ax, label=\"Channel\")\nnode_geometry(drrmodel.unpaved.unp_nodes)[0].plot(\n    ax=ax, markersize=30, marker=\"s\", color=\"green\", label=\"Unpaved\"\n)\nnode_geometry(drrmodel.unpaved.unp_nodes)[1].plot(ax=ax, color=\"black\", linewidth=0.5)\nnode_geometry(drrmodel.paved.pav_nodes)[0].plot(ax=ax, markersize=20, marker=\"s\", color=\"red\", label=\"Paved\")\nnode_geometry(drrmodel.paved.pav_nodes)[1].plot(ax=ax, color=\"black\", linewidth=0.5)\nnode_geometry(drrmodel.greenhouse.gh_nodes)[0].plot(ax=ax, markersize=15, color=\"yellow\", label=\"Greenhouse\")\nnode_geometry(drrmodel.greenhouse.gh_nodes)[1].plot(ax=ax, color=\"black\", linewidth=0.5)\nnode_geometry(drrmodel.openwater.ow_nodes)[0].plot(ax=ax, markersize=10, color=\"blue\", label=\"Openwater\")\nnode_geometry(drrmodel.openwater.ow_nodes)[1].plot(ax=ax, color=\"black\", linewidth=0.5, label=\"RR-link\")\nnode_geometry(drrmodel.external_forcings.boundary_nodes)[0].plot(\n    ax=ax, markersize=15, color=\"purple\", label=\"RR Boundary\"\n)\n\n# manually add handles for polygon plot\nhandles, labels = ax.get_legend_handles_labels()\npoly = mpatches.Patch(facecolor=\"pink\", edgecolor=\"black\", alpha=0.5)\ncx.add_basemap(ax, crs=28992, source=cx.providers.OpenStreetMap.Mapnik)\nax.legend(handles=handles.append(poly), labels=labels.append(\"Catchments\"))\nfig.tight_layout()\n</code></pre>"},{"location":"dhydamo/getting_started/tutorial/#writing-the-model","title":"Writing the model","text":"<p>Now we call Hydrolib-core functionality to write the model. First, we initialize an object that converts all dataframes to Hydrolib-core objects. Then we add these models to the file structure of the FM model.</p> <p>Call a function to convert the dataframes to Hydrolib-core classes:</p> <pre><code>models = Df2HydrolibModel(hydamo)\n</code></pre> <p>And add the classes to the file structure</p> <pre><code>fm.geometry.structurefile = [StructureModel(structure=models.structures)]\nfm.geometry.crosslocfile = CrossLocModel(crosssection=models.crosslocs)\nfm.geometry.crossdeffile = CrossDefModel(definition=models.crossdefs)\n\nfm.geometry.frictfile = []\nfor i, fric_def in enumerate(models.friction_defs):\n    fric_model = FrictionModel(global_=fric_def)\n    fric_model.filepath = f\"roughness_{i}.ini\"\n    fm.geometry.frictfile.append(fric_model)\n\nfm.output.obsfile = [ObservationPointModel(observationpoint=models.obspoints)]\n\nextmodel = ExtModel()\nextmodel.boundary = models.boundaries_ext\nextmodel.lateral = models.laterals_ext\nfm.external_forcing.extforcefilenew = extmodel\n\nfm.geometry.inifieldfile = IniFieldModel(initial=models.inifields)\n# for ifield, onedfield in enumerate(models.onedfieldmodels):\n#     fm.geometry.inifieldfile.initial[ifield].datafile = OneDFieldModel(\n#         global_= onedfield\n#     )\n</code></pre> <p>Now we write the file structure:</p> <pre><code>fm.filepath = Path(output_path) / \"fm\" / \"test.mdu\"\ndimr = DIMR()\ndimr.component.append(\n    FMComponent(name=\"DFM\", workingDir=Path(output_path) / \"fm\", model=fm, inputfile=fm.filepath)    \n)\ndimr.save(recurse=True)\n</code></pre> <pre><code>import shutil\nshutil.copy(data_path / \"initialWaterDepth.ini\", output_path / \"fm\")\n</code></pre> <pre><code>'D:\\\\3640.20\\\\HYDROLIB-dhydamo\\\\hydrolib\\\\tests\\\\model2\\\\fm\\\\initialWaterDepth.ini'\n</code></pre> <p>This is not done yet. Use the delft3dfmpy writers for the RR-part:</p> <pre><code>if RTC:\n    drtcmodel.write_xml_v1()\n</code></pre> <pre><code>if RR:\n    rr_writer = DRRWriter(drrmodel, output_dir=output_path, name=\"test\", wwtp=(199000.0, 396000.0))\n    rr_writer.write_all()\n</code></pre> <pre><code>dimr = DIMRWriter(output_path=output_path)\ndimr.write_dimrconfig(fm, rr_model=drrmodel, rtc_model=drtcmodel)\ndimr.write_runbat()\n</code></pre> <pre><code>print(\"Done!\")\n</code></pre> <pre><code>Done!\n</code></pre> <pre><code>\n</code></pre>"},{"location":"dhydamo/reference/api/","title":"Api","text":""},{"location":"dhydamo/reference/api/#dhydamo","title":"DHyDAMO","text":"<p>The API references of DHyDAMO can be found below:</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.CrossSectionsIO","title":"<code>CrossSectionsIO</code>","text":"Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>class CrossSectionsIO:\n    def __init__(self, crosssections):\n        self.crosssections = crosssections\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def from_datamodel(\n        self, crsdefs: pd.DataFrame = None, crslocs: pd.DataFrame = None\n    ) -&gt; None:\n        \"\"\" \"\n        From parsed data models of crsdefs and crslocs\n        \"\"\"\n\n        if crslocs is not None:\n            for _, crsloc in crslocs.iterrows():\n                # add location\n                self.crosssections.add_crosssection_location(\n                    branchid=crsloc[\"branch_id\"],\n                    chainage=crsloc[\"branch_offset\"],\n                    shift=crsloc[\"shift\"],\n                    definition=crsloc[\"crosssectiondefinitionid\"],\n                )\n\n        if crsdefs is not None:\n            crsdefs = crsdefs.drop_duplicates(subset=[\"crosssectiondefinitionid\"])\n            for _, crsdef in crsdefs.iterrows():\n                # Set roughness value on default if cross-section has non defined (e.g. culverts)\n                if isinstance(crsdef[\"frictionid\"], str):\n                    roughtype = crsdef[\"frictionid\"].split(\"_\")[0]\n                else:\n                    roughtype = \"Chezy\"\n\n                if isinstance(crsdef[\"frictionid\"], str):\n                    roughval = float(crsdef[\"frictionid\"].split(\"_\")[-1])\n                else:\n                    roughval = 45\n\n                # add definition\n                if crsdef[\"type\"] == \"circle\":\n                    self.crosssections.add_circle_definition(\n                        diameter=crsdef[\"diameter\"],\n                        roughnesstype=roughtype,\n                        roughnessvalue=roughval,\n                        name=crsdef[\"crosssectiondefinitionid\"],\n                    )\n                elif crsdef[\"type\"] == \"rectangle\":\n                    self.crosssections.add_rectangle_definition(\n                        height=crsdef[\"height\"],\n                        width=crsdef[\"width\"],\n                        closed=crsdef[\"closed\"],\n                        roughnesstype=roughtype,\n                        roughnessvalue=roughval,\n                        name=crsdef[\"crosssectiondefinitionid\"],\n                    )\n                elif crsdef[\"type\"] == \"trapezium\":\n                    self.crosssections.add_trapezium_definition(\n                        slope=(crsdef[\"t_width\"] - crsdef[\"width\"])\n                        / 2\n                        / crsdef[\"height\"],\n                        maximumflowwidth=crsdef[\"t_width\"],\n                        bottomwidth=crsdef[\"width\"],\n                        closed=crsdef[\"closed\"],\n                        roughnesstype=roughtype,\n                        roughnessvalue=roughval,\n                        name=crsdef[\"crosssectiondefinitionid\"],\n                    )\n                elif crsdef[\"type\"] == \"zw\":\n                    self.crosssections.add_zw_definition(\n                        numLevels=crsdef[\"numlevels\"],\n                        levels=crsdef[\"levels\"],\n                        flowWidths=crsdef[\"flowwidths\"],\n                        totalWidths=crsdef[\"totalwidths\"],\n                        roughnesstype=roughtype,\n                        roughnessvalue=roughval,\n                        name=crsdef[\"crosssectiondefinitionid\"],\n                    )\n\n                else:\n                    raise NotImplementedError\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def profiles(\n        self,\n        branches: ExtendedGeoDataFrame, # = None,\n        roughness_variant: RoughnessVariant,# =None,\n        crosssections: Optional[ExtendedGeoDataFrame] = None,\n        crosssection_roughness: Optional[ExtendedDataFrame] = None,\n        profile_groups: Optional[ExtendedDataFrame] = None,\n        profile_lines: Optional[ExtendedGeoDataFrame] = None,\n        param_profile: Optional[ExtendedDataFrame] = None,\n        param_profile_values: Optional[ExtendedDataFrame] = None,\n    ) -&gt; None:\n        \"\"\"\n        Method to add cross section from hydamo files. Two files\n        can be handed to the function, the cross section file (dwarsprofiel) and the\n        parametrised file (normgeparametriseerd). The\n        hierarchical order is 1. dwarsprofiel, 2. normgeparametriseerd.\n        Each branch will be assigned a profile following this order. If parametrised\n        and standard are not given, branches can be wit hout cross section. In that case\n        a standard profile should be assigned\n        \"\"\"\n        dp_branches = None\n        dp_structures = None\n        if profile_groups is not None:\n            # check for profile_groups items with valid brugid or stuwid. They need to be droppped from profiles.\n            groupidx = [\n                idx\n                for idx, group in profile_groups.iterrows()\n                if (\"brugid\" in profile_groups.columns) &amp; (not pd.isnull(group.brugid))\n            ]\n\n            groupidx = groupidx + [\n                idx\n                for idx, group in profile_groups.iterrows()\n                if (\"stuwid\" in profile_groups.columns) &amp; (not pd.isnull(group.stuwid))\n            ]\n\n            # index of the lines that are associated to these groups\n            lineidx = [\n                profile_lines[\n                    profile_lines[\"profielgroepid\"]\n                    == profile_groups.loc[grindex, \"globalid\"]\n                ].index.values[0]\n                for grindex in groupidx\n            ]\n            # index of the profiles associated to these lines\n            profidx = [\n                crosssections[\n                    crosssections[\"profiellijnid\"]\n                    == profile_lines.loc[lindex, \"globalid\"]\n                ].index.values[0]\n                for lindex in lineidx\n            ]\n            # make a copy and drop the profiles corresponding to a structure\n            dp_branches = crosssections.copy(deep=True)\n            dp_branches.drop(profidx, axis=0, inplace=True)\n\n            dp_structures = crosssections.copy(deep=True)\n            dp_structures = dp_structures.loc[profidx, :]\n        else:\n            dp_branches = crosssections.copy(deep=True)\n\n        # Assign cross-sections to branches\n        nnocross = len(self.crosssections.get_branches_without_crosssection())\n        print(\n            f\"Before adding the number of branches without cross section is: {nnocross}.\"\n        )\n\n        if dp_branches is not None:\n            # 1. Collect cross sections from 'dwarsprofielen'\n            yz_profiles = self.crosssections.crosssection_to_yzprofiles(\n                dp_branches,\n                crosssection_roughness,\n                branches,\n                roughness_variant=roughness_variant,\n            )\n\n            for name, css in yz_profiles.items():\n                # Add definition\n                self.crosssections.add_yz_definition(\n                    yz=css[\"yz\"],\n                    thalweg=css[\"thalweg\"],\n                    name=name,\n                    roughnesstype=css[\"typeruwheid\"],\n                    roughnessvalue=css[\"ruwheid\"],\n                )\n                # Add location\n                self.crosssections.add_crosssection_location(\n                    branchid=css[\"branchid\"], chainage=css[\"chainage\"], definition=name\n                )\n\n        # Check the number of branches with cross sections\n        no_crosssection_id = self.crosssections.get_branches_without_crosssection()\n        no_crosssection = [\n            b for b in branches.itertuples() if b.code in no_crosssection_id\n        ]\n\n        nnocross = len(no_crosssection)\n        print(\n            f\"After adding 'dwarsprofielen' the number of branches without cross section is: {nnocross}.\"\n        )\n        if nnocross == 0:\n            print(\"No further branches without a profile.\")\n        elif param_profile is None:\n            print(\"No parametrised crossections available for branches.\")\n        else:\n            # Derive norm cross sections for norm parametrised\n            param_profiles_converted = self.crosssections.parametrised_to_profiles(\n                param_profile,\n                param_profile_values,\n                no_crosssection,\n                roughness_variant=roughness_variant,\n            )\n            # Get branch information\n            branchdata = self.crosssections.hydamo.branches.loc[\n                list(param_profiles_converted.keys())\n            ]\n            branchdata[\"chainage_upper\"] = 0.05 * branchdata.length\n            branchdata[\"chainage_lower\"] = 0.95 * branchdata.length\n\n\n            # Add cross sections\n            for branchid, css in param_profiles_converted.items():\n                chainage_upper = branchdata.at[branchid, \"chainage_upper\"]\n                chainage_lower = branchdata.at[branchid, \"chainage_lower\"]\n\n                if css[\"type\"] == \"rectangle\":\n                    name = self.crosssections.add_rectangle_definition(\n                        height=css[\"height\"],\n                        width=css[\"width\"],\n                        closed=css[\"closed\"],\n                        roughnesstype=css[\"typeruwheid\"],\n                        roughnessvalue=css[\"ruwheid\"],\n                    )\n\n                if css[\"type\"] == \"trapezium\":\n                    name = self.crosssections.add_trapezium_definition(\n                        slope=css[\"slope\"],\n                        maximumflowwidth=css[\"maximumflowwidth\"],\n                        bottomwidth=css[\"bottomwidth\"],\n                        closed=css[\"closed\"],\n                        roughnesstype=css[\"typeruwheid\"],\n                        roughnessvalue=css[\"ruwheid\"],\n                    )\n\n                # Add location\n                self.crosssections.add_crosssection_location(\n                    branchid=branchid,\n                    chainage=chainage_upper,\n                    definition=name,\n                    shift=css[\"bottomlevel_upper\"],\n                )\n\n                self.crosssections.add_crosssection_location(\n                    branchid=branchid,\n                    chainage=chainage_lower,\n                    definition=name,\n                    shift=css[\"bottomlevel_lower\"],\n                )\n\n        nnocross = len(self.crosssections.get_branches_without_crosssection())\n        print(\n            f\"After adding 'normgeparametriseerd' the number of branches without cross section is: {nnocross}.\"\n        )\n\n        if dp_structures is not None:\n            # 1. Collect cross sections from 'dwarsprofielen'\n            yz_profiles = self.crosssections.crosssection_to_yzprofiles(\n                dp_structures,\n                crosssection_roughness,\n                None,\n                roughness_variant=roughness_variant,\n            )\n\n            for name, css in yz_profiles.items():\n                # Add definition\n                self.crosssections.add_yz_definition(\n                    yz=css[\"yz\"],\n                    thalweg=css[\"thalweg\"],\n                    name=name,\n                    roughnesstype=css[\"typeruwheid\"],\n                    roughnessvalue=css[\"ruwheid\"],\n                )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.CrossSectionsIO.from_datamodel","title":"<code>from_datamodel(crsdefs: pd.DataFrame = None, crslocs: pd.DataFrame = None) -&gt; None</code>","text":"<p>\" From parsed data models of crsdefs and crslocs</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef from_datamodel(\n    self, crsdefs: pd.DataFrame = None, crslocs: pd.DataFrame = None\n) -&gt; None:\n    \"\"\" \"\n    From parsed data models of crsdefs and crslocs\n    \"\"\"\n\n    if crslocs is not None:\n        for _, crsloc in crslocs.iterrows():\n            # add location\n            self.crosssections.add_crosssection_location(\n                branchid=crsloc[\"branch_id\"],\n                chainage=crsloc[\"branch_offset\"],\n                shift=crsloc[\"shift\"],\n                definition=crsloc[\"crosssectiondefinitionid\"],\n            )\n\n    if crsdefs is not None:\n        crsdefs = crsdefs.drop_duplicates(subset=[\"crosssectiondefinitionid\"])\n        for _, crsdef in crsdefs.iterrows():\n            # Set roughness value on default if cross-section has non defined (e.g. culverts)\n            if isinstance(crsdef[\"frictionid\"], str):\n                roughtype = crsdef[\"frictionid\"].split(\"_\")[0]\n            else:\n                roughtype = \"Chezy\"\n\n            if isinstance(crsdef[\"frictionid\"], str):\n                roughval = float(crsdef[\"frictionid\"].split(\"_\")[-1])\n            else:\n                roughval = 45\n\n            # add definition\n            if crsdef[\"type\"] == \"circle\":\n                self.crosssections.add_circle_definition(\n                    diameter=crsdef[\"diameter\"],\n                    roughnesstype=roughtype,\n                    roughnessvalue=roughval,\n                    name=crsdef[\"crosssectiondefinitionid\"],\n                )\n            elif crsdef[\"type\"] == \"rectangle\":\n                self.crosssections.add_rectangle_definition(\n                    height=crsdef[\"height\"],\n                    width=crsdef[\"width\"],\n                    closed=crsdef[\"closed\"],\n                    roughnesstype=roughtype,\n                    roughnessvalue=roughval,\n                    name=crsdef[\"crosssectiondefinitionid\"],\n                )\n            elif crsdef[\"type\"] == \"trapezium\":\n                self.crosssections.add_trapezium_definition(\n                    slope=(crsdef[\"t_width\"] - crsdef[\"width\"])\n                    / 2\n                    / crsdef[\"height\"],\n                    maximumflowwidth=crsdef[\"t_width\"],\n                    bottomwidth=crsdef[\"width\"],\n                    closed=crsdef[\"closed\"],\n                    roughnesstype=roughtype,\n                    roughnessvalue=roughval,\n                    name=crsdef[\"crosssectiondefinitionid\"],\n                )\n            elif crsdef[\"type\"] == \"zw\":\n                self.crosssections.add_zw_definition(\n                    numLevels=crsdef[\"numlevels\"],\n                    levels=crsdef[\"levels\"],\n                    flowWidths=crsdef[\"flowwidths\"],\n                    totalWidths=crsdef[\"totalwidths\"],\n                    roughnesstype=roughtype,\n                    roughnessvalue=roughval,\n                    name=crsdef[\"crosssectiondefinitionid\"],\n                )\n\n            else:\n                raise NotImplementedError\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.CrossSectionsIO.profiles","title":"<code>profiles(branches: ExtendedGeoDataFrame, roughness_variant: RoughnessVariant, crosssections: Optional[ExtendedGeoDataFrame] = None, crosssection_roughness: Optional[ExtendedDataFrame] = None, profile_groups: Optional[ExtendedDataFrame] = None, profile_lines: Optional[ExtendedGeoDataFrame] = None, param_profile: Optional[ExtendedDataFrame] = None, param_profile_values: Optional[ExtendedDataFrame] = None) -&gt; None</code>","text":"<p>Method to add cross section from hydamo files. Two files can be handed to the function, the cross section file (dwarsprofiel) and the parametrised file (normgeparametriseerd). The hierarchical order is 1. dwarsprofiel, 2. normgeparametriseerd. Each branch will be assigned a profile following this order. If parametrised and standard are not given, branches can be wit hout cross section. In that case a standard profile should be assigned</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef profiles(\n    self,\n    branches: ExtendedGeoDataFrame, # = None,\n    roughness_variant: RoughnessVariant,# =None,\n    crosssections: Optional[ExtendedGeoDataFrame] = None,\n    crosssection_roughness: Optional[ExtendedDataFrame] = None,\n    profile_groups: Optional[ExtendedDataFrame] = None,\n    profile_lines: Optional[ExtendedGeoDataFrame] = None,\n    param_profile: Optional[ExtendedDataFrame] = None,\n    param_profile_values: Optional[ExtendedDataFrame] = None,\n) -&gt; None:\n    \"\"\"\n    Method to add cross section from hydamo files. Two files\n    can be handed to the function, the cross section file (dwarsprofiel) and the\n    parametrised file (normgeparametriseerd). The\n    hierarchical order is 1. dwarsprofiel, 2. normgeparametriseerd.\n    Each branch will be assigned a profile following this order. If parametrised\n    and standard are not given, branches can be wit hout cross section. In that case\n    a standard profile should be assigned\n    \"\"\"\n    dp_branches = None\n    dp_structures = None\n    if profile_groups is not None:\n        # check for profile_groups items with valid brugid or stuwid. They need to be droppped from profiles.\n        groupidx = [\n            idx\n            for idx, group in profile_groups.iterrows()\n            if (\"brugid\" in profile_groups.columns) &amp; (not pd.isnull(group.brugid))\n        ]\n\n        groupidx = groupidx + [\n            idx\n            for idx, group in profile_groups.iterrows()\n            if (\"stuwid\" in profile_groups.columns) &amp; (not pd.isnull(group.stuwid))\n        ]\n\n        # index of the lines that are associated to these groups\n        lineidx = [\n            profile_lines[\n                profile_lines[\"profielgroepid\"]\n                == profile_groups.loc[grindex, \"globalid\"]\n            ].index.values[0]\n            for grindex in groupidx\n        ]\n        # index of the profiles associated to these lines\n        profidx = [\n            crosssections[\n                crosssections[\"profiellijnid\"]\n                == profile_lines.loc[lindex, \"globalid\"]\n            ].index.values[0]\n            for lindex in lineidx\n        ]\n        # make a copy and drop the profiles corresponding to a structure\n        dp_branches = crosssections.copy(deep=True)\n        dp_branches.drop(profidx, axis=0, inplace=True)\n\n        dp_structures = crosssections.copy(deep=True)\n        dp_structures = dp_structures.loc[profidx, :]\n    else:\n        dp_branches = crosssections.copy(deep=True)\n\n    # Assign cross-sections to branches\n    nnocross = len(self.crosssections.get_branches_without_crosssection())\n    print(\n        f\"Before adding the number of branches without cross section is: {nnocross}.\"\n    )\n\n    if dp_branches is not None:\n        # 1. Collect cross sections from 'dwarsprofielen'\n        yz_profiles = self.crosssections.crosssection_to_yzprofiles(\n            dp_branches,\n            crosssection_roughness,\n            branches,\n            roughness_variant=roughness_variant,\n        )\n\n        for name, css in yz_profiles.items():\n            # Add definition\n            self.crosssections.add_yz_definition(\n                yz=css[\"yz\"],\n                thalweg=css[\"thalweg\"],\n                name=name,\n                roughnesstype=css[\"typeruwheid\"],\n                roughnessvalue=css[\"ruwheid\"],\n            )\n            # Add location\n            self.crosssections.add_crosssection_location(\n                branchid=css[\"branchid\"], chainage=css[\"chainage\"], definition=name\n            )\n\n    # Check the number of branches with cross sections\n    no_crosssection_id = self.crosssections.get_branches_without_crosssection()\n    no_crosssection = [\n        b for b in branches.itertuples() if b.code in no_crosssection_id\n    ]\n\n    nnocross = len(no_crosssection)\n    print(\n        f\"After adding 'dwarsprofielen' the number of branches without cross section is: {nnocross}.\"\n    )\n    if nnocross == 0:\n        print(\"No further branches without a profile.\")\n    elif param_profile is None:\n        print(\"No parametrised crossections available for branches.\")\n    else:\n        # Derive norm cross sections for norm parametrised\n        param_profiles_converted = self.crosssections.parametrised_to_profiles(\n            param_profile,\n            param_profile_values,\n            no_crosssection,\n            roughness_variant=roughness_variant,\n        )\n        # Get branch information\n        branchdata = self.crosssections.hydamo.branches.loc[\n            list(param_profiles_converted.keys())\n        ]\n        branchdata[\"chainage_upper\"] = 0.05 * branchdata.length\n        branchdata[\"chainage_lower\"] = 0.95 * branchdata.length\n\n\n        # Add cross sections\n        for branchid, css in param_profiles_converted.items():\n            chainage_upper = branchdata.at[branchid, \"chainage_upper\"]\n            chainage_lower = branchdata.at[branchid, \"chainage_lower\"]\n\n            if css[\"type\"] == \"rectangle\":\n                name = self.crosssections.add_rectangle_definition(\n                    height=css[\"height\"],\n                    width=css[\"width\"],\n                    closed=css[\"closed\"],\n                    roughnesstype=css[\"typeruwheid\"],\n                    roughnessvalue=css[\"ruwheid\"],\n                )\n\n            if css[\"type\"] == \"trapezium\":\n                name = self.crosssections.add_trapezium_definition(\n                    slope=css[\"slope\"],\n                    maximumflowwidth=css[\"maximumflowwidth\"],\n                    bottomwidth=css[\"bottomwidth\"],\n                    closed=css[\"closed\"],\n                    roughnesstype=css[\"typeruwheid\"],\n                    roughnessvalue=css[\"ruwheid\"],\n                )\n\n            # Add location\n            self.crosssections.add_crosssection_location(\n                branchid=branchid,\n                chainage=chainage_upper,\n                definition=name,\n                shift=css[\"bottomlevel_upper\"],\n            )\n\n            self.crosssections.add_crosssection_location(\n                branchid=branchid,\n                chainage=chainage_lower,\n                definition=name,\n                shift=css[\"bottomlevel_lower\"],\n            )\n\n    nnocross = len(self.crosssections.get_branches_without_crosssection())\n    print(\n        f\"After adding 'normgeparametriseerd' the number of branches without cross section is: {nnocross}.\"\n    )\n\n    if dp_structures is not None:\n        # 1. Collect cross sections from 'dwarsprofielen'\n        yz_profiles = self.crosssections.crosssection_to_yzprofiles(\n            dp_structures,\n            crosssection_roughness,\n            None,\n            roughness_variant=roughness_variant,\n        )\n\n        for name, css in yz_profiles.items():\n            # Add definition\n            self.crosssections.add_yz_definition(\n                yz=css[\"yz\"],\n                thalweg=css[\"thalweg\"],\n                name=name,\n                roughnesstype=css[\"typeruwheid\"],\n                roughnessvalue=css[\"ruwheid\"],\n            )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO","title":"<code>ExternalForcingsIO</code>","text":"Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>class ExternalForcingsIO:\n    def __init__(self, external_forcings):\n        self.external_forcings = external_forcings\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def boundaries(\n        self, boundary_conditions: ExtendedGeoDataFrame, mesh1d: Network = None\n    ) -&gt; None:\n        \"\"\"\n        Generate boundary conditions from hydamo 'randvoorwaarden' file. The file format does not allow for timeseries.\n\n        To add a time series, use 'add_boundary' from the workflow.\n\n        Parameters\n        ----------\n        boundary_conditions: gpd.GeoDataFrame\n            geodataframe with the locations and properties of the boundary conditions\n\n        Returns\n        -------\n        dictionary\n            Dictionary with attributes of boundary conditions, usable for dflowfm\n        \"\"\"\n        # Read from Hydamo\n        bcdct = {}\n\n        for bndcnd in boundary_conditions.itertuples():\n            if \"waterstand\" in bndcnd.typerandvoorwaarde:\n                quantity = \"waterlevelbnd\"\n            elif \"debiet\" in bndcnd.typerandvoorwaarde:\n                quantity = \"dischargebnd\"\n\n            # Add boundary condition\n            bcdct[bndcnd.code] = {\n                \"code\": bndcnd.code,\n                \"quantity\": quantity,\n                \"value\": bndcnd.waterstand\n                if not np.isnan(bndcnd.waterstand)\n                else bndcnd.debiet,\n                \"time\": None,\n                \"geometry\": bndcnd.geometry,\n            }\n\n        # Add all items\n        for key, item in bcdct.items():\n            self.external_forcings.add_boundary_condition(\n                key, item[\"geometry\"], item[\"quantity\"], item[\"value\"], mesh1d=mesh1d\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def laterals(\n        self,\n        locations: ExtendedGeoDataFrame,\n        overflows: Optional[ExtendedGeoDataFrame] = None,\n        greenhouse_laterals: Optional[ExtendedGeoDataFrame] = None,\n        lateral_discharges: Optional[Union[pd.DataFrame, pd.Series]]=None,\n        rr_boundaries: Optional[dict] = None,\n    ) -&gt; None:\n        \"\"\"\n        Process laterals\n\n        Parameters\n        ----------\n        locations: gpd.GeoDataFrame\n            GeoDataFrame with at least 'geometry' (Point) and the column 'code'\n        lateral_discharges: pd.DataFrame\n            DataFrame with lateral discharges. The index should be a time object (datetime or similar).\n        rr_boundaries: pd.DataFrame\n            DataFrame with RR-catchments that are coupled\n        \"\"\"\n\n        if rr_boundaries is None:\n            rr_boundaries = []\n\n        # in case of 3d points, remove the 3rd dimension\n        locations[\"geometry2\"] = [\n            Point([point.geometry.x, point.geometry.y])\n            for _, point in locations.iterrows()\n        ]\n        locations.drop(\"geometry\", inplace=True, axis=1)\n        locations.rename(columns={\"geometry2\": \"geometry\"}, inplace=True)\n\n        latdct = {}\n        if overflows is not None:\n            locations = pd.concat([locations, overflows], ignore_index=True)\n        if greenhouse_laterals is not None:\n            locations = pd.concat([locations, greenhouse_laterals], ignore_index=True)\n\n        # Get time series and add to dictionary\n        # for nidx, lateral in zip(nearest_idx, locations.itertuples()):\n        for lateral in locations.itertuples():\n            # Check if a time is provided for the lateral\n            if lateral.code in rr_boundaries:\n                # Add to dictionary\n                latdct[lateral.code] = {\n                    \"branchid\": lateral.branch_id,\n                    \"chainage\": str(lateral.branch_offset),\n                    \"discharge\": \"realtime\",\n                }\n\n            else:\n                if lateral_discharges is None:\n                    logger.warning(\n                        f\"No lateral_discharges provided. {lateral.code} expects them. Skipping.\"\n                    )\n                else:\n                    if isinstance(lateral_discharges, pd.Series):\n                        series = lateral_discharges.loc[lateral.code]\n\n                        # Add to dictionary\n                        latdct[lateral.code] = {\n                            \"branchid\": lateral.branch_id,\n                            \"chainage\": str(lateral.branch_offset),\n                            \"discharge\": series,\n                        }\n\n                    else:\n                        if lateral.code not in lateral_discharges.columns:\n                            logger.warning(\n                                f\"No data found for {lateral.code}. Skipping.\"\n                            )\n                            continue\n\n                        # Get timeseries\n                        series = lateral_discharges.loc[:, lateral.code]\n\n                        # Add to dictionary\n                        latdct[lateral.code] = {\n                            \"branchid\": lateral.branch_id,\n                            \"chainage\": str(lateral.branch_offset),\n                            \"discharge\": series,\n                        }\n\n        # Add all items\n        for key, item in latdct.items():\n            self.external_forcings.add_lateral(\n                id=key,\n                branchid=item[\"branchid\"],\n                chainage=item[\"chainage\"],\n                discharge=item[\"discharge\"],\n            )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO.boundaries","title":"<code>boundaries(boundary_conditions: ExtendedGeoDataFrame, mesh1d: Network = None) -&gt; None</code>","text":"<p>Generate boundary conditions from hydamo 'randvoorwaarden' file. The file format does not allow for timeseries.</p> <p>To add a time series, use 'add_boundary' from the workflow.</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO.boundaries--parameters","title":"Parameters","text":"<p>boundary_conditions: gpd.GeoDataFrame     geodataframe with the locations and properties of the boundary conditions</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO.boundaries--returns","title":"Returns","text":"<p>dictionary     Dictionary with attributes of boundary conditions, usable for dflowfm</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef boundaries(\n    self, boundary_conditions: ExtendedGeoDataFrame, mesh1d: Network = None\n) -&gt; None:\n    \"\"\"\n    Generate boundary conditions from hydamo 'randvoorwaarden' file. The file format does not allow for timeseries.\n\n    To add a time series, use 'add_boundary' from the workflow.\n\n    Parameters\n    ----------\n    boundary_conditions: gpd.GeoDataFrame\n        geodataframe with the locations and properties of the boundary conditions\n\n    Returns\n    -------\n    dictionary\n        Dictionary with attributes of boundary conditions, usable for dflowfm\n    \"\"\"\n    # Read from Hydamo\n    bcdct = {}\n\n    for bndcnd in boundary_conditions.itertuples():\n        if \"waterstand\" in bndcnd.typerandvoorwaarde:\n            quantity = \"waterlevelbnd\"\n        elif \"debiet\" in bndcnd.typerandvoorwaarde:\n            quantity = \"dischargebnd\"\n\n        # Add boundary condition\n        bcdct[bndcnd.code] = {\n            \"code\": bndcnd.code,\n            \"quantity\": quantity,\n            \"value\": bndcnd.waterstand\n            if not np.isnan(bndcnd.waterstand)\n            else bndcnd.debiet,\n            \"time\": None,\n            \"geometry\": bndcnd.geometry,\n        }\n\n    # Add all items\n    for key, item in bcdct.items():\n        self.external_forcings.add_boundary_condition(\n            key, item[\"geometry\"], item[\"quantity\"], item[\"value\"], mesh1d=mesh1d\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO.laterals","title":"<code>laterals(locations: ExtendedGeoDataFrame, overflows: Optional[ExtendedGeoDataFrame] = None, greenhouse_laterals: Optional[ExtendedGeoDataFrame] = None, lateral_discharges: Optional[Union[pd.DataFrame, pd.Series]] = None, rr_boundaries: Optional[dict] = None) -&gt; None</code>","text":"<p>Process laterals</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.ExternalForcingsIO.laterals--parameters","title":"Parameters","text":"<p>locations: gpd.GeoDataFrame     GeoDataFrame with at least 'geometry' (Point) and the column 'code' lateral_discharges: pd.DataFrame     DataFrame with lateral discharges. The index should be a time object (datetime or similar). rr_boundaries: pd.DataFrame     DataFrame with RR-catchments that are coupled</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef laterals(\n    self,\n    locations: ExtendedGeoDataFrame,\n    overflows: Optional[ExtendedGeoDataFrame] = None,\n    greenhouse_laterals: Optional[ExtendedGeoDataFrame] = None,\n    lateral_discharges: Optional[Union[pd.DataFrame, pd.Series]]=None,\n    rr_boundaries: Optional[dict] = None,\n) -&gt; None:\n    \"\"\"\n    Process laterals\n\n    Parameters\n    ----------\n    locations: gpd.GeoDataFrame\n        GeoDataFrame with at least 'geometry' (Point) and the column 'code'\n    lateral_discharges: pd.DataFrame\n        DataFrame with lateral discharges. The index should be a time object (datetime or similar).\n    rr_boundaries: pd.DataFrame\n        DataFrame with RR-catchments that are coupled\n    \"\"\"\n\n    if rr_boundaries is None:\n        rr_boundaries = []\n\n    # in case of 3d points, remove the 3rd dimension\n    locations[\"geometry2\"] = [\n        Point([point.geometry.x, point.geometry.y])\n        for _, point in locations.iterrows()\n    ]\n    locations.drop(\"geometry\", inplace=True, axis=1)\n    locations.rename(columns={\"geometry2\": \"geometry\"}, inplace=True)\n\n    latdct = {}\n    if overflows is not None:\n        locations = pd.concat([locations, overflows], ignore_index=True)\n    if greenhouse_laterals is not None:\n        locations = pd.concat([locations, greenhouse_laterals], ignore_index=True)\n\n    # Get time series and add to dictionary\n    # for nidx, lateral in zip(nearest_idx, locations.itertuples()):\n    for lateral in locations.itertuples():\n        # Check if a time is provided for the lateral\n        if lateral.code in rr_boundaries:\n            # Add to dictionary\n            latdct[lateral.code] = {\n                \"branchid\": lateral.branch_id,\n                \"chainage\": str(lateral.branch_offset),\n                \"discharge\": \"realtime\",\n            }\n\n        else:\n            if lateral_discharges is None:\n                logger.warning(\n                    f\"No lateral_discharges provided. {lateral.code} expects them. Skipping.\"\n                )\n            else:\n                if isinstance(lateral_discharges, pd.Series):\n                    series = lateral_discharges.loc[lateral.code]\n\n                    # Add to dictionary\n                    latdct[lateral.code] = {\n                        \"branchid\": lateral.branch_id,\n                        \"chainage\": str(lateral.branch_offset),\n                        \"discharge\": series,\n                    }\n\n                else:\n                    if lateral.code not in lateral_discharges.columns:\n                        logger.warning(\n                            f\"No data found for {lateral.code}. Skipping.\"\n                        )\n                        continue\n\n                    # Get timeseries\n                    series = lateral_discharges.loc[:, lateral.code]\n\n                    # Add to dictionary\n                    latdct[lateral.code] = {\n                        \"branchid\": lateral.branch_id,\n                        \"chainage\": str(lateral.branch_offset),\n                        \"discharge\": series,\n                    }\n\n    # Add all items\n    for key, item in latdct.items():\n        self.external_forcings.add_lateral(\n            id=key,\n            branchid=item[\"branchid\"],\n            chainage=item[\"chainage\"],\n            discharge=item[\"discharge\"],\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StorageNodesIO","title":"<code>StorageNodesIO</code>","text":"Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>class StorageNodesIO:\n    def __init__(self, storagenodes):\n        self.storagenodes = storagenodes\n\n    def storagenodes_from_datamodel(self, storagenodes):\n        \"\"\" \"From parsed data model of storage nodes\"\"\"\n        for storagenode_idx, storagenode in storagenodes.iterrows():\n            self.add_storagenode(\n                id=storagenode.id,\n                name=storagenode.name if \"name\" in storagenode.index else np.nan,\n                usestreetstorage=storagenode.usestreetstorage,\n                nodetype=\"unspecified\",\n                nodeid=storagenode.nodeid,\n                usetable=\"false\",\n                bedlevel=storagenode.bedlevel,\n                area=storagenode.area,\n                streetlevel=storagenode.streetlevel,\n                streetstoragearea=storagenode.streetstoragearea,\n                storagetype=storagenode.storagetype,\n            )\n\n    def storagenodes_from_input(self, storagenodes=None, nodeid=None, xy=None, storagedata=None, usestreetstorage= True, network=None):\n        \"\"\" \"From parsed data model of storage nodes\"\"\"\n\n        for storagenode_idx, storagenode in storagenodes.iterrows():\n            data = storagedata[storagedata.code == storagenode_idx]\n            name = storagenode.name\n            if pd.isna(name):\n                name = storagenode.code\n            self.storagenodes.add_storagenode(\n                id=storagenode_idx,\n                name=name,\n                usestreetstorage=usestreetstorage,\n                nodetype=\"unspecified\",\n                nodeid=nodeid,\n                xy=xy,\n                branchid=storagenode.branch_id,\n                chainage=storagenode.branch_offset,\n                usetable=\"true\",\n                storagearea=' '.join(data.area.astype(str)),\n                levels=' '.join(data.level.astype(str)),\n                network=network\n            )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StorageNodesIO.storagenodes_from_datamodel","title":"<code>storagenodes_from_datamodel(storagenodes)</code>","text":"<p>\"From parsed data model of storage nodes</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>def storagenodes_from_datamodel(self, storagenodes):\n    \"\"\" \"From parsed data model of storage nodes\"\"\"\n    for storagenode_idx, storagenode in storagenodes.iterrows():\n        self.add_storagenode(\n            id=storagenode.id,\n            name=storagenode.name if \"name\" in storagenode.index else np.nan,\n            usestreetstorage=storagenode.usestreetstorage,\n            nodetype=\"unspecified\",\n            nodeid=storagenode.nodeid,\n            usetable=\"false\",\n            bedlevel=storagenode.bedlevel,\n            area=storagenode.area,\n            streetlevel=storagenode.streetlevel,\n            streetstoragearea=storagenode.streetstoragearea,\n            storagetype=storagenode.storagetype,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StorageNodesIO.storagenodes_from_input","title":"<code>storagenodes_from_input(storagenodes=None, nodeid=None, xy=None, storagedata=None, usestreetstorage=True, network=None)</code>","text":"<p>\"From parsed data model of storage nodes</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>def storagenodes_from_input(self, storagenodes=None, nodeid=None, xy=None, storagedata=None, usestreetstorage= True, network=None):\n    \"\"\" \"From parsed data model of storage nodes\"\"\"\n\n    for storagenode_idx, storagenode in storagenodes.iterrows():\n        data = storagedata[storagedata.code == storagenode_idx]\n        name = storagenode.name\n        if pd.isna(name):\n            name = storagenode.code\n        self.storagenodes.add_storagenode(\n            id=storagenode_idx,\n            name=name,\n            usestreetstorage=usestreetstorage,\n            nodetype=\"unspecified\",\n            nodeid=nodeid,\n            xy=xy,\n            branchid=storagenode.branch_id,\n            chainage=storagenode.branch_offset,\n            usetable=\"true\",\n            storagearea=' '.join(data.area.astype(str)),\n            levels=' '.join(data.level.astype(str)),\n            network=network\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO","title":"<code>StructuresIO</code>","text":"Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>class StructuresIO:\n    def __init__(self, structures):\n        self.structures = structures\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def generalstructures_from_datamodel(self, generalstructures: pd.DataFrame) -&gt; None:\n        \"\"\"From parsed data model of orifices\n\n        Args:\n            generalstructures (pd.DataFrame): dataframe containing the data\n        \"\"\"\n\n        for generalstructure_idx, generalstructure in generalstructures.iterrows():\n            self.structures.add_generalstructure(\n                id=generalstructure.id,\n                name=generalstructure.name\n                if \"name\" in generalstructure.index\n                else np.nan,\n                branchid=generalstructure.branch_id,\n                chainage=generalstructure.branch_offset,\n                allowedflowdir=\"both\",\n                upstream1width=generalstructure.upstream1width\n                if \"upstream1width\" in generalstructure.index\n                else np.nan,\n                upstream1level=generalstructure.upstream1level\n                if \"upstream1level\" in generalstructure.index\n                else np.nan,\n                upstream2width=generalstructure.upstream2width\n                if \"upstream2width\" in generalstructure.index\n                else np.nan,\n                upstream2level=generalstructure.upstream2level\n                if \"upstream2level\" in generalstructure.index\n                else np.nan,\n                crestwidth=generalstructure.crestwidth\n                if \"crestwidth\" in generalstructure.index\n                else np.nan,\n                crestlevel=generalstructure.crestlevel\n                if \"crestlevel\" in generalstructure.index\n                else np.nan,\n                crestlength=generalstructure.crestlength\n                if \"crestlength\" in generalstructure.index\n                else np.nan,\n                downstream1width=generalstructure.downstream1width\n                if \"downstream1width\" in generalstructure.index\n                else np.nan,\n                downstream1level=generalstructure.downstream1level\n                if \"downstream1level\" in generalstructure.index\n                else np.nan,\n                downstream2width=generalstructure.downstream2width\n                if \"downstream2width\" in generalstructure.index\n                else np.nan,\n                downstream2level=generalstructure.downstream2level\n                if \"downstream2level\" in generalstructure.index\n                else np.nan,\n                gateloweredgelevel=generalstructure.gateloweredgelevel\n                if \"gateloweredgelevel\" in generalstructure.index\n                else np.nan,\n                posfreegateflowcoeff=generalstructure.posfreegateflowcoeff\n                if \"posfreegateflowcoeff\" in generalstructure.index\n                else np.nan,\n                posdrowngateflowcoeff=generalstructure.posdrowngateflowcoeff\n                if \"posdrowngateflowcoeff\" in generalstructure.index\n                else np.nan,\n                posfreeweirflowcoeff=generalstructure.posfreeweirflowcoeff\n                if \"posfreeweirflowcoeff\" in generalstructure.index\n                else np.nan,\n                posdrownweirflowcoeff=generalstructure.posdrownweirflowcoeff\n                if \"posdrownweirflowcoeff\" in generalstructure.index\n                else np.nan,\n                poscontrcoeffreegate=generalstructure.poscontrcoeffreegate\n                if \"poscontrcoeffreegate\" in generalstructure.index\n                else np.nan,\n                negfreegateflowcoeff=generalstructure.negfreegateflowcoeff\n                if \"negfreegateflowcoeff\" in generalstructure.index\n                else np.nan,\n                negdrowngateflowcoeff=generalstructure.negdrowngateflowcoeff\n                if \"negdrowngateflowcoeff\" in generalstructure.index\n                else np.nan,\n                negfreeweirflowcoeff=generalstructure.negfreeweirflowcoeff\n                if \"negfreeweirflowcoeff\" in generalstructure.index\n                else np.nan,\n                negdrownweirflowcoeff=generalstructure.negdrownweirflowcoeff\n                if \"negdrownweirflowcoeff\" in generalstructure.index\n                else np.nan,\n                negcontrcoeffreegate=generalstructure.negcontrcoeffreegate\n                if \"negcontrcoeffreegate\" in generalstructure.index\n                else np.nan,\n                extraresistance=generalstructure.extraresistance\n                if \"extraresistance\" in generalstructure.index\n                else np.nan,\n                gateheight=generalstructure.gateheight\n                if \"gateheight\" in generalstructure.index\n                else np.nan,\n                gateopeningwidth=generalstructure.gateopeningwidth\n                if \"gateopeningwidth\" in generalstructure.index\n                else np.nan,\n                gateopeninghorizontaldirection=generalstructure.gateopeninghorizontaldirection\n                if \"gateopeninghorizontaldirection\" in generalstructure.index\n                else np.nan,\n                usevelocityheight=generalstructure.usevelocityheight\n                if \"usevelocityheight\" in generalstructure.index\n                else np.nan,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def weirs(\n        self,\n        weirs: ExtendedGeoDataFrame = None,\n        profile_groups = None,\n        profile_lines = None,\n        profiles: Optional[ExtendedGeoDataFrame] = None,\n        opening: ExtendedDataFrame = None,\n        management_device: ExtendedDataFrame = None,\n        usevelocityheight: Optional[str] = \"true\",\n    ) -&gt; None:\n        \"\"\"\n        Method to convert HyDAMO weirs to DFlowFM structures: regular weirs, orifices and universal weirs.\n        If a weir ID corresponds to a 'stuwid' in the profile_groups object, a universal weir is created.\n        If the management_device corresponding to a weir has the field \"overlaatonderlaat\" set to \"onderlaat', an orifice is schematized. In all other cases, a regular (rectangular) weir is created.\n\n        Parameters corrspond to the HyDAMO DAMO2.2 objects. DFlowFM keyword 'usevelocityheight' can be specificied as a string, default is 'true'.\n        \"\"\"\n        # bypass HyDAMO and add stuwid directly to managment for use in RTC\n        if not self.structures.hydamo.management.empty:\n            self.structures.hydamo.management['stuwid'] = None\n\n        index = np.zeros((len(weirs.code)))\n        if profile_groups is not None and hasattr(profile_groups, \"stuwid\"):\n            index[np.isin(weirs.globalid, np.asarray(profile_groups.stuwid))] = 1\n\n        rweirs = weirs[index == 0]\n        for weir in rweirs.itertuples():\n            weir_opening = opening[opening.stuwid == weir.globalid]\n\n            # check if a separate name field is present\n            if \"naam\" in weirs:\n                name = weir.naam\n                if not name:\n                    name = weir.code\n            else:\n                name = weir.code\n\n            if weir_opening.shape[0] &gt; 1:\n                print(f'Weir {weir.code} contains {weir_opening.shape[0]} openings. Creating a compound structure with a fictional weir for each one.')\n                cmp_list = []\n                for num_op, (_, op_row) in enumerate(weir_opening.iterrows()):\n                    weir_mandev = management_device[\n                        management_device.kunstwerkopeningid\n                        == op_row.globalid\n                    ]\n                    weir_id = f'{weir.code}_{num_op+1}'\n                    if (not self.structures.hydamo.management.empty) &amp; (hasattr(self.structures.hydamo.management, 'regelmiddelid')):\n                        if weir_mandev.globalid.isin(self.structures.hydamo.management.regelmiddelid).item():\n                            idx = self.structures.hydamo.management[self.structures.hydamo.management.regelmiddelid == weir_mandev.globalid.squeeze()].index.values[0]\n                            self.structures.hydamo.management.loc[idx, 'stuwid'] =weir_id\n                    if weir_mandev.overlaatonderlaat.squeeze().lower() == 'overlaat':\n                        cmp_list.append(weir_id)\n                        self.structures.add_rweir(id=weir_id,\n                                                    name=name,\n                                                    branchid=weir.branch_id,\n                                                    chainage=weir.branch_offset,\n                                                    crestlevel=op_row.laagstedoorstroomhoogte,\n                                                    crestwidth=op_row.laagstedoorstroombreedte,\n                                                    corrcoeff=weir.afvoercoefficient,\n                                                    allowedflowdir=\"both\",\n                                                    usevelocityheight=usevelocityheight,\n                                                 )\n                    elif weir_mandev.overlaatonderlaat.squeeze().lower() == 'onderlaat':\n                        cmp_list.append(weir_id)\n                        if \"maximaaldebiet\" not in weir_mandev or pd.isnull(weir_mandev.maximaaldebiet.values[0]):\n                            limitflow = \"false\"\n                            maxq = 0.0\n                        else:\n                            limitflow = \"true\"\n                            maxq = float(weir_mandev.maximaaldebiet.values[0])\n                        self.structures.add_orifice(\n                            id=weir_id,\n                            name=name,\n                            branchid=weir.branch_id,\n                            chainage=weir.branch_offset,\n                            crestlevel=float(weir_opening.laagstedoorstroomhoogte.values[0]),\n                            crestwidth=float(weir_opening.laagstedoorstroombreedte.values[0]),\n                            corrcoeff=weir.afvoercoefficient,\n                            allowedflowdir=\"both\",\n                            usevelocityheight=usevelocityheight,\n                            gateloweredgelevel=float(weir_opening.laagstedoorstroomhoogte.values[0])\n                            + float(weir_mandev.hoogteopening.values[0]),\n                            uselimitflowpos=limitflow,\n                            limitflowpos=maxq,\n                            uselimitflowneg=limitflow,\n                            limitflowneg=maxq,\n                        )\n                    else:\n                        print(f'Skipping {weir.code} - from \"overlaatonderlaat\" {weir_mandev.overlaatonderlaat} the type of structure could not be determined.')\n                self.structures.add_compound(id=f'cmp_{weir.code}', structureids =cmp_list)\n                # self.structures.rweirs_df.drop(weir.code)\n            else:\n                if weir_opening.empty:\n                    print(f'Skipping {weir.code} because there is no associated opening.')\n                    continue\n\n                weir_id = weir.code\n                weir_mandev = management_device[\n                        management_device.kunstwerkopeningid\n                        == weir_opening.globalid.values[0]\n                    ]\n\n                if weir_mandev.empty:\n                    print(f'Skipping {weir.code} because there is no associated management device.')\n                    continue\n\n                if (not self.structures.hydamo.management.empty) &amp; hasattr(self.structures.hydamo.management, 'regelmiddelid'):\n                    if weir_mandev.globalid.isin(self.structures.hydamo.management.regelmiddelid).item():\n                        idx = self.structures.hydamo.management[self.structures.hydamo.management.regelmiddelid == weir_mandev.globalid.squeeze()].index.values[0]\n                        self.structures.hydamo.management.loc[idx, 'stuwid'] = weir_id\n\n\n                if isinstance(weir_mandev.overlaatonderlaat, pd.Series):\n                    overlaatonderlaat = weir_mandev.overlaatonderlaat.squeeze()\n                else:\n                    overlaatonderlaat = weir_mandev.overlaatonderlaat\n\n                if (\n                    overlaatonderlaat.lower()\n                    == \"overlaat\"\n                ):\n                    self.structures.add_rweir(\n                        id=weir_id,\n                        name=name,\n                        branchid=weir.branch_id,\n                        chainage=weir.branch_offset,\n                        crestlevel=weir_opening.laagstedoorstroomhoogte.values[0],\n                        crestwidth=weir_opening.laagstedoorstroombreedte.values[0],\n                        corrcoeff=weir.afvoercoefficient,\n                        allowedflowdir=\"both\",\n                        usevelocityheight=usevelocityheight,\n                    )\n\n                elif (\n                    overlaatonderlaat.lower()\n                    == \"onderlaat\"\n                ):\n                    if \"maximaaldebiet\" not in weir_mandev or pd.isnull(weir_mandev.maximaaldebiet.values[0]):\n                        limitflow = \"false\"\n                        maxq = 0.0\n                    else:\n                        limitflow = \"true\"\n                        maxq = float(weir_mandev.maximaaldebiet.values[0])\n                    self.structures.add_orifice(\n                        id=weir_id,\n                        name=name,\n                        branchid=weir.branch_id,\n                        chainage=weir.branch_offset,\n                        crestlevel=float(weir_opening.laagstedoorstroomhoogte.values[0]),\n                        crestwidth=float(weir_opening.laagstedoorstroombreedte.values[0]),\n                        corrcoeff=weir.afvoercoefficient,\n                        allowedflowdir=\"both\",\n                        usevelocityheight=usevelocityheight,\n                        gateloweredgelevel=float(weir_opening.laagstedoorstroomhoogte.values[0])\n                        + float(weir_mandev.hoogteopening.values[0]),\n                        uselimitflowpos=limitflow,\n                        limitflowpos=maxq,\n                        uselimitflowneg=limitflow,\n                        limitflowneg=maxq,\n                    )\n                else:\n                    print(f'Skipping {weir.code} - from \"overlaatonderlaat\" {weir_mandev.overlaatonderlaat} the type of structure could not be determined.')\n\n        uweirs = weirs[index == 1]\n        for uweir in uweirs.itertuples():\n            # check if a separate name field is present\n            if \"naam\" in uweirs:\n                name = uweir.naam\n            else:\n                name = uweir.code\n\n            prof = np.empty(0)\n            if (profiles is not None) &amp; (\"stuwid\" in profile_groups):\n                group = profile_groups[profile_groups[\"stuwid\"] == uweir.globalid]\n                line = profile_lines[\n                    profile_lines[\"profielgroepid\"] == group[\"globalid\"].values[0]\n                ]\n                prof = profiles[profiles[\"profiellijnid\"] == line[\"globalid\"].values[0]]\n                if not prof.empty:\n                    counts = len(prof.geometry.iloc[0].coords[:])\n                    xyz = np.vstack(prof.geometry.iloc[0].coords[:])\n                    length = np.r_[\n                        0,\n                        np.cumsum(np.hypot(np.diff(xyz[:, 0]), np.diff(xyz[:, 1]))),\n                    ]\n                    yzvalues = np.c_[length, xyz[:, -1] - np.min(xyz[:, -1])]\n\n            if not hasattr(uweir, 'laagstedoorstroomhoogte') or pd.isnull(uweir.laagstedoorstroomhoogte):\n                kruinhoogte = np.min(xyz[:,-1])\n            else:\n                kruinhoogte = uweir.laagstedoorstroomhoogte\n\n            if len(prof) == 0:\n                # return an error it is still not found\n                raise ValueError(f\"{uweir.code} is not found in any cross-section.\")\n            self.structures.add_uweir(\n                id=uweir.code,\n                name=name,\n                branchid=uweir.branch_id,\n                chainage=uweir.branch_offset,\n                crestlevel=kruinhoogte,\n                dischargecoeff=uweir.afvoercoefficient,\n                allowedflowdir=\"both\",\n                numlevels=counts,\n                yvalues=\" \".join([f\"{yz[0]:7.3f}\" for yz in yzvalues]),\n                zvalues=\" \".join([f\"{yz[1]:7.3f}\" for yz in yzvalues]),\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def weirs_from_datamodel(self, weirs: pd.DataFrame) -&gt; None:\n        \"\"\" \"From parsed data model of weirs\"\"\"\n        for weir_idx, weir in weirs.iterrows():\n            self.structures.add_weir(\n                id=weir.id,\n                name=weir.name if \"name\" in weir.index else np.nan,\n                branchid=weir.branch_id,\n                chainage=weir.branch_offset,\n                crestlevel=weir.crestlevel,\n                crestwidth=weir.crestwidth,\n                corrcoeff=weir.corrcoeff,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def orifices_from_datamodel(self, orifices: pd.DataFrame) -&gt; None:\n        \"\"\" \"From parsed data model of orifices\"\"\"\n        for orifice_idx, orifice in orifices.iterrows():\n            self.structures.add_orifice(\n                id=orifice.id,\n                name=orifice.name if \"name\" in orifice.index else np.nan,\n                branchid=orifice.branch_id,\n                chainage=orifice.branch_offset,\n                allowedflowdir=\"both\",\n                crestlevel=orifice.crestlevel,\n                crestwidth=orifice.crestwidth,\n                gateloweredgelevel=orifice.gateloweredgelevel,\n                corrcoeff=orifice.corrcoef,\n                uselimitflowpos=orifice.uselimitflowpos,\n                limitflowpos=orifice.limitflowpos,\n                uselimitflowneg=orifice.uselimitflowneg,\n                limitflowneg=orifice.limitflowneg,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def uweirs_from_datamodel(self, uweirs: pd.DataFrame) -&gt; None:\n        \"\"\" \"From parsed data model of universal weirs\"\"\"\n        for uweir_idx, uweir in uweirs.iterrows():\n            self.structures.add_uweir(\n                id=uweir.id,\n                name=uweir.name if \"name\" in uweir.index else np.nan,\n                branchid=uweir.branch_id,\n                chainage=uweir.branch_offset,\n                crestlevel=uweir.crestlevel,\n                yvalues=uweir.yvalues,\n                zvalues=uweir.zvalues,\n                allowedflowdir=\"both\",\n                dischargecoeff=uweir.dischargecoeff,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def bridges(\n        self,\n        bridges: ExtendedGeoDataFrame,\n        profile_groups: ExtendedDataFrame = None,\n        profile_lines: ExtendedGeoDataFrame = None,\n        profiles: ExtendedGeoDataFrame = None,\n    ) -&gt; None:\n        \"\"\"\n        Method to convert HyDAMO bridges to DFlowFM bridges. Every bridge needs an associated YZ-profile through profile_groups ('brugid'), profile_lines and profiles.\n\n        Parameters corrspond to the HyDAMO DAMO2.2 objects.\n        \"\"\"\n        for bridge in bridges.itertuples():\n            # first search in yz-profiles\n            group = profile_groups[profile_groups[\"brugid\"] == bridge.globalid]\n            line = profile_lines[\n                profile_lines[\"profielgroepid\"] == group[\"globalid\"].values[0]\n            ]\n            prof = profiles[profiles[\"profiellijnid\"] == line[\"globalid\"].values[0]]\n\n            if len(prof) == 0:\n                raise ValueError(f\"{bridge.code} is not found in any cross-section.\")\n\n            if \"naam\" in bridges:\n                name = bridge.naam\n            else:\n                name = bridge.code\n\n            profile_id = prof.code.values[0]\n            self.structures.add_bridge(\n                id=bridge.code,\n                name=name,\n                branchid=bridge.branch_id,\n                chainage=bridge.branch_offset,\n                csdefid=profile_id,\n                shift=0.0,\n                allowedflowdir=\"both\",\n                inletlosscoeff=bridge.intreeverlies,\n                outletlosscoeff=bridge.uittreeverlies,\n                length=bridge.lengte,\n                frictiontype=bridge.typeruwheid,\n                friction=bridge.ruwheid,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def bridges_from_datamodel(self, bridges: pd.DataFrame) -&gt; None:\n        \"\"\" \"From parsed data model of bridges\"\"\"\n        for bridge_idx, bridge in bridges.iterrows():\n            self.structures.add_bridge(\n                id=bridge.code,\n                name=bridge.name if \"name\" in bridge.index else np.nan,\n                branchid=bridge.branch_id,\n                chainage=bridge.branch_offset,\n                csdefid=bridge.csdefid,\n                shift=0.0,\n                allowedflowdir=\"both\",\n                inletlosscoeff=bridge.intreeverlies,\n                outletlosscoeff=bridge.uittreeverlies,\n                length=bridge.lengte,\n                frictiontype=bridge.typeruwheid,\n                friction=bridge.ruwheid,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def culverts(\n        self,\n        culverts: ExtendedGeoDataFrame,\n        management_device: Optional[ExtendedDataFrame] = None,\n    ) -&gt; None:\n        \"\"\"\n        Method to convert HyDAMO culverts to DFlowFM culverts. Devices like a valve and a slide can be schematized from the management_device object.\n        According to HyDAMO DAMO2.2 a closing_device ('afsluitmiddel') could also be used but this is not supported.\n\n        Parameters corrspond to the HyDAMO DAMO2.2 objects.\n        \"\"\"\n        if management_device is not None:\n            if 'soortafsluitmiddel' not in management_device.columns:\n               management_device['soortafsluitmiddel'] = management_device['soortregelmiddel']\n\n        for culvert in culverts.itertuples():\n            # Generate cross section definition name\n            if culvert.vormkoker.lower() == \"rond\" or culvert.vormkoker.lower() == \"ellipsvormig\":\n                crosssection = {\"shape\": \"circle\", \"diameter\": culvert.hoogteopening}\n            elif (\n                culvert.vormkoker.lower() == \"rechthoekig\"\n                or culvert.vormkoker.lower() == \"onbekend\"\n                or culvert.vormkoker.lower() == \"eivormig\"\n                or culvert.vormkoker.lower() == \"muilprofiel\"\n                or culvert.vormkoker.lower() == \"heulprofiel\"\n            ):\n                crosssection = {\n                    \"shape\": \"rectangle\",\n                    \"height\": culvert.hoogteopening,\n                    \"width\": culvert.breedteopening,\n                    \"closed\": 1,\n                }\n            else:\n                crosssection = {\"shape\": \"circle\", \"diameter\": 0.40}\n                print(\n                    f\"Culvert {culvert.code} has an unknown shape: {culvert.vormkoker}. Applying a default profile (round - 40cm)\"\n                )\n\n            # check whether an afsluitmiddel is present and take action dependent on its settings\n            if management_device is not None:\n                mandev = management_device[\n                    management_device.duikersifonhevelid == culvert.globalid\n                ]\n                if 'soortafsluitmiddel' not in mandev:\n                    mandev.loc[mandev.index,'soortafsluitmiddel'] = mandev['soortregelmiddel']\n            else:\n                mandev = pd.DataFrame()\n\n            if mandev.empty:\n                allowedflowdir = \"both\"\n                valveonoff = 0\n                numlosscoeff = None\n                valveopeningheight = 0\n                relopening = None\n                losscoeff = None\n            else:\n                for _, i in mandev.iterrows():\n                    if i[\"soortafsluitmiddel\"] == \"terugslagklep\":\n                        allowedflowdir = \"positive\"\n                        valveonoff = 0\n                        numlosscoeff = None\n                        valveopeningheight = 0\n                        relopening = None\n                        losscoeff = None\n                    elif i[\"soortafsluitmiddel\"] == \"schuif\":\n                        allowedflowdir = \"positive\"\n                        valveonoff = 1\n                        valveopeningheight = float(i[\"hoogteopening\"])\n                        numlosscoeff = 1\n                        relopening = [float(i[\"hoogteopening\"]) / culvert.hoogteopening]\n                        losscoeff = [float(i[\"afvoercoefficient\"])]\n                    else:\n                        raise NotImplementedError(\n                            f'Type of management device for culvert {culvert.code} is not implemented; only \"schuif\" and \"terugslagklep\" are allowed.'\n                        )\n\n            # check if a separate name field is present\n            if \"naam\" in culverts:\n                name = culvert.naam\n            else:\n                name = culvert.code\n\n            self.structures.add_culvert(\n                id=culvert.code,\n                name=name,\n                branchid=culvert.branch_id,\n                chainage=culvert.branch_offset,\n                leftlevel=culvert.hoogtebinnenonderkantbov,\n                rightlevel=culvert.hoogtebinnenonderkantbene,\n                length=culvert.lengte,\n                inletlosscoeff=culvert.intreeverlies,\n                outletlosscoeff=culvert.uittreeverlies,\n                crosssection=crosssection,\n                allowedflowdir=allowedflowdir,\n                valveonoff=valveonoff,\n                numlosscoeff=numlosscoeff,\n                valveopeningheight=valveopeningheight,\n                relopening=relopening,\n                losscoeff=losscoeff,\n                bedfrictiontype=culvert.typeruwheid,\n                bedfriction=culvert.ruwheid,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def culverts_from_datamodel(self, culverts: pd.DataFrame) -&gt; None:\n        \"\"\"\n        From parsed model of culverts\n        \"\"\"\n\n        # Add to dict\n        for culvert_idx, culvert in culverts.iterrows():\n            self.structures.add_culvert(\n                id=culvert.id,\n                name=culvert.name if \"name\" in culvert.index else np.nan,\n                branchid=culvert.branch_id,\n                chainage=culvert.branch_offset,\n                leftlevel=culvert.leftlevel,\n                rightlevel=culvert.rightlevel,\n                crosssection=culvert.crosssectiondefinitionid,\n                length=culvert.geometry.length\n                if \"geometry\" in culvert.index\n                else culvert.length,\n                inletlosscoeff=culvert.inletlosscoeff,\n                outletlosscoeff=culvert.outletlosscoeff,\n                allowedflowdir=\"both\",\n                valveonoff=0,\n                numlosscoeff=0,\n                valveopeningheight=np.nan,\n                relopening=np.nan,\n                losscoeff=np.nan,\n                frictiontype=culvert.frictiontype,\n                frictionvalue=culvert.frictionvalue,\n            )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def pumps(\n        self,\n        pumpstations: ExtendedGeoDataFrame,\n        pumps: ExtendedDataFrame = None,\n        management: ExtendedDataFrame = None,\n    ) -&gt; None:\n        \"\"\"\n        Method to convert HyDAMO pumps to DFlowFM pumps. Three objects are required: pumpstations, pumps and management ('sturing').\n\n        Parameters corrspond to the HyDAMO DAMO2.2 objects.\n        \"\"\"\n\n        # Add sturing to pumps\n        for pumpstation in pumpstations.itertuples():\n\n            # find pumps for gemaal\n            pumps_subset = pumps[pumps.gemaalid == pumpstation.globalid]\n            if pumps_subset.empty:\n                print(f'Skipping {pumpstation.code} because there is no associated pump.')\n                continue\n\n            if \"naam\" in pumpstation:\n                name = pumpstation.name\n            else:\n                name = pumpstation.code\n            if pumps_subset.shape[0] &gt; 1:\n                # more than one pump\n                cmp_list = []\n                print(f'Pumpstation {pumpstation.code} contains {pumps_subset.shape[0]} openings. Creating a compound structure with a fictional pump for each one.')\n                for ipump, (_,pump) in enumerate(pumps_subset.iterrows()):\n\n                    pump_control = management[management.pompid== pump.globalid]\n                    if pump_control.empty:\n                        print(f'No management found for {pump.code}')\n                        continue\n\n                    startlevelsuctionside = [pump_control[\"bovengrens\"]]\n                    stoplevelsuctionside = [pump_control[\"ondergrens\"]]\n\n                    pumpid = f'{pumpstation.code}_{ipump+1}'\n                    cmp_list.append(pumpid)\n\n                    self.structures.add_pump(\n                        id=pumpid,\n                        name=name,\n                        branchid=pumpstation.branch_id,\n                        chainage=pumpstation.branch_offset,\n                        orientation=\"positive\",\n                        numstages=1,\n                        controlside=\"suctionside\",\n                        capacity=pump.maximalecapaciteit/60.,\n                        startlevelsuctionside=startlevelsuctionside,\n                        stoplevelsuctionside=stoplevelsuctionside,\n                        startleveldeliveryside=startlevelsuctionside,\n                        stopleveldeliveryside=stoplevelsuctionside,\n                    )\n                self.structures.add_compound(id=f'cmp_{pumpstation.code}', structureids =cmp_list)\n\n            else:\n                #  only one pump\n                pump_control = management[management.pompid== pumps_subset.globalid.values[0]]\n                if pump_control.empty:\n                    print(f'Skipping {pumpstation.code} because there is no associated management.')\n\n                startlevelsuctionside = [pump_control[\"bovengrens\"]]\n                stoplevelsuctionside = [pump_control[\"ondergrens\"]]\n\n\n                # the pumpstation has only one pump\n                self.structures.add_pump(\n                    id=pumpstation.code,\n                    name=name,\n                    branchid=pumpstation.branch_id,\n                    chainage=pumpstation.branch_offset,\n                    orientation=\"positive\",\n                    numstages=1,\n                    controlside=\"suctionside\",\n                    capacity=pumps_subset.maximalecapaciteit.values[0]/60.,\n                    startlevelsuctionside=startlevelsuctionside,\n                    stoplevelsuctionside=stoplevelsuctionside,\n                    startleveldeliveryside=startlevelsuctionside,\n                    stopleveldeliveryside=stoplevelsuctionside,\n                )\n\n    @validate_arguments(config=dict(arbitrary_types_allowed=True))\n    def pumps_from_datamodel(self, pumps: pd.DataFrame) -&gt; None:\n        \"\"\"From parsed data model of pumps\"\"\"\n\n        for pump_idx, pump in pumps.iterrows():\n            self.structures.add_pump(\n                id=pump.id,\n                name=pump.name if \"name\" in pump.index else np.nan,\n                branchid=pump.branch_id,\n                chainage=pump.branch_offset,\n                orientation=\"positive\",\n                numstages=1,\n                controlside=pump.controlside,\n                capacity=pump.maximumcapacity,\n                startlevelsuctionside=pump.startlevelsuctionside,\n                stoplevelsuctionside=pump.stoplevelsuctionside,\n                startleveldeliveryside=pump.startleveldeliveryside,\n                stopleveldeliveryside=pump.stopleveldeliveryside,\n            )\n\n    @staticmethod\n    def move_structure(struc, struc_dict, branch, offset):\n        \"\"\"\n        Function the move a structure if needed for a compound structure.\n\n        Parameters\n        ----------\n        struc : string\n            current sub-structure id\n        struc_dict : dict\n            dict with all structures of a certain type\n        branch : string\n            branch id of the first structure in the compound\n        offset : float\n            chainage of the first structure in the compound\n\n        Returns\n        -------\n        Dict with shifted coordinates.\n\n        \"\"\"\n        branch2 = struc_dict[struc][\"branchid\"]\n        if branch2 != branch:\n            logger.warning(\n                f\"Structures of not on the same branche. Moving structure {struc} to branch {branch}.\"\n            )\n        struc_dict[struc][\"branchid\"] = branch\n        struc_dict[struc][\"chainage\"] = offset\n        return struc_dict\n\n    def compound_structures(self, idlist, structurelist):\n        # probably the coordinates should all be set to those of the first structure (still to do)\n        for c_i, c_id in enumerate(idlist):\n            # check the substructure coordinates. If they do not coincide, move subsequent structures to the coordinates of the first\n            for s_i, struc in enumerate(structurelist[c_i]):\n                if s_i == 0:\n                    # find out what type the first structure it is and get its coordinates\n                    if not self.structures.pumps_df.empty:\n                        if struc in list(self.structures.pumps_df.id):\n                            branch = self.structures.pumps_df[\n                                self.structures.pumps_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.pumps_df[\n                                self.structures.pumps_df.id == struc\n                            ].chainage.values[0]\n                    if not self.structures.rweirs_df.empty:\n                        if struc in list(self.structures.rweirs_df.id):\n                            branch = self.structures.rweirs_df[\n                                self.structures.rweirs_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.rweirs_df[\n                                self.structures.rweirs_df.id == struc\n                            ].chainage.values[0]\n                    if not self.structures.uweirs_df.empty:\n                        if struc in list(self.structures.uweirs_df.id):\n                            branch = self.structures.uweirs_df[\n                                self.structures.uweirs_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.uweirs_df[\n                                self.structures.uweirs_df.id == struc\n                            ].chainage.values[0]\n                    if not self.structures.culverts_df.empty:\n                        if struc in list(self.structures.culverts_df.id):\n                            branch = self.structures.culverts_df[\n                                self.structures.culverts_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.culverts_df[\n                                self.structures.culverts_df.id == struc\n                            ].chainage.values[0]\n                    if not self.structures.bridges_df.empty:\n                        if struc in list(self.structures.bridges_df.id):\n                            branch = self.structures.bridges_df[\n                                self.structures.bridges_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.bridges_df[\n                                self.structures.bridges_df.id == struc\n                            ].chainage.values[0]\n                    if not self.structures.orifices_df.empty:\n                        if struc in list(self.structures.orifices_df.id):\n                            branch = self.structures.orifices_df[\n                                self.structures.orifices_df.id == struc\n                            ].branchid.values[0]\n                            offset = self.structures.orifices_df[\n                                self.structures.orifices_df.id == struc\n                            ].chainage.values[0]\n                else:\n                    # move a subsequent structure to the location of the first\n                    if not self.structures.pumps_df.empty:\n                        if struc in list(self.structures.pumps_df.id):\n                            self.structures.pumps_df.loc[\n                                self.structures.pumps_df[\n                                    self.structures.pumps_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.pumps_df.loc[\n                                self.structures.pumps_df[\n                                    self.structures.pumps_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n                    if not self.structures.rweirs_df.empty:\n                        if struc in list(self.structures.rweirs_df.id):\n                            self.structures.rweirs_df.loc[\n                                self.structures.rweirs_df[\n                                    self.structures.rweirs_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.rweirs_df.loc[\n                                self.structures.rweirs_df[\n                                    self.structures.rweirs_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n                    if not self.structures.uweirs_df.empty:\n                        if struc in list(self.structures.uweirs_df.id):\n                            self.structures.uweirs_df.loc[\n                                self.structures.uweirs_df[\n                                    self.structures.uweirs_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.uweirs_df.loc[\n                                self.structures.uweirs_df[\n                                    self.structures.uweirs_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n                    if not self.structures.culverts_df.empty:\n                        if struc in list(self.structures.culverts_df.id):\n                            self.structures.culverts_df.loc[\n                                self.structures.culverts_df[\n                                    self.structures.culverts_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.culverts_df.loc[\n                                self.structures.culverts_df[\n                                    self.structures.culverts_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n                    if not self.structures.bridges_df.empty:\n                        if struc in list(self.structures.bridges_df.id):\n                            self.structures.bridges_df.loc[\n                                self.structures.bridges_df[\n                                    self.structures.bridges_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.bridges_df.loc[\n                                self.structures.bridges_df[\n                                    self.structures.bridges_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n                    if not self.structures.orifices_df.empty:\n                        if struc in list(self.structures.orifices_df.id):\n                            self.structures.orifices_df.loc[\n                                self.structures.orifices_df[\n                                    self.structures.orifices_df.id == struc\n                                ].index,\n                                \"branchid\",\n                            ] = branch\n                            self.structures.orifices_df.loc[\n                                self.structures.orifices_df[\n                                    self.structures.orifices_df.id == struc\n                                ].index,\n                                \"chainage\",\n                            ] = offset\n\n            self.structures.add_compound(id=c_id, structureids=structurelist[c_i])\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.bridges","title":"<code>bridges(bridges: ExtendedGeoDataFrame, profile_groups: ExtendedDataFrame = None, profile_lines: ExtendedGeoDataFrame = None, profiles: ExtendedGeoDataFrame = None) -&gt; None</code>","text":"<p>Method to convert HyDAMO bridges to DFlowFM bridges. Every bridge needs an associated YZ-profile through profile_groups ('brugid'), profile_lines and profiles.</p> <p>Parameters corrspond to the HyDAMO DAMO2.2 objects.</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef bridges(\n    self,\n    bridges: ExtendedGeoDataFrame,\n    profile_groups: ExtendedDataFrame = None,\n    profile_lines: ExtendedGeoDataFrame = None,\n    profiles: ExtendedGeoDataFrame = None,\n) -&gt; None:\n    \"\"\"\n    Method to convert HyDAMO bridges to DFlowFM bridges. Every bridge needs an associated YZ-profile through profile_groups ('brugid'), profile_lines and profiles.\n\n    Parameters corrspond to the HyDAMO DAMO2.2 objects.\n    \"\"\"\n    for bridge in bridges.itertuples():\n        # first search in yz-profiles\n        group = profile_groups[profile_groups[\"brugid\"] == bridge.globalid]\n        line = profile_lines[\n            profile_lines[\"profielgroepid\"] == group[\"globalid\"].values[0]\n        ]\n        prof = profiles[profiles[\"profiellijnid\"] == line[\"globalid\"].values[0]]\n\n        if len(prof) == 0:\n            raise ValueError(f\"{bridge.code} is not found in any cross-section.\")\n\n        if \"naam\" in bridges:\n            name = bridge.naam\n        else:\n            name = bridge.code\n\n        profile_id = prof.code.values[0]\n        self.structures.add_bridge(\n            id=bridge.code,\n            name=name,\n            branchid=bridge.branch_id,\n            chainage=bridge.branch_offset,\n            csdefid=profile_id,\n            shift=0.0,\n            allowedflowdir=\"both\",\n            inletlosscoeff=bridge.intreeverlies,\n            outletlosscoeff=bridge.uittreeverlies,\n            length=bridge.lengte,\n            frictiontype=bridge.typeruwheid,\n            friction=bridge.ruwheid,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.bridges_from_datamodel","title":"<code>bridges_from_datamodel(bridges: pd.DataFrame) -&gt; None</code>","text":"<p>\"From parsed data model of bridges</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef bridges_from_datamodel(self, bridges: pd.DataFrame) -&gt; None:\n    \"\"\" \"From parsed data model of bridges\"\"\"\n    for bridge_idx, bridge in bridges.iterrows():\n        self.structures.add_bridge(\n            id=bridge.code,\n            name=bridge.name if \"name\" in bridge.index else np.nan,\n            branchid=bridge.branch_id,\n            chainage=bridge.branch_offset,\n            csdefid=bridge.csdefid,\n            shift=0.0,\n            allowedflowdir=\"both\",\n            inletlosscoeff=bridge.intreeverlies,\n            outletlosscoeff=bridge.uittreeverlies,\n            length=bridge.lengte,\n            frictiontype=bridge.typeruwheid,\n            friction=bridge.ruwheid,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.culverts","title":"<code>culverts(culverts: ExtendedGeoDataFrame, management_device: Optional[ExtendedDataFrame] = None) -&gt; None</code>","text":"<p>Method to convert HyDAMO culverts to DFlowFM culverts. Devices like a valve and a slide can be schematized from the management_device object. According to HyDAMO DAMO2.2 a closing_device ('afsluitmiddel') could also be used but this is not supported.</p> <p>Parameters corrspond to the HyDAMO DAMO2.2 objects.</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef culverts(\n    self,\n    culverts: ExtendedGeoDataFrame,\n    management_device: Optional[ExtendedDataFrame] = None,\n) -&gt; None:\n    \"\"\"\n    Method to convert HyDAMO culverts to DFlowFM culverts. Devices like a valve and a slide can be schematized from the management_device object.\n    According to HyDAMO DAMO2.2 a closing_device ('afsluitmiddel') could also be used but this is not supported.\n\n    Parameters corrspond to the HyDAMO DAMO2.2 objects.\n    \"\"\"\n    if management_device is not None:\n        if 'soortafsluitmiddel' not in management_device.columns:\n           management_device['soortafsluitmiddel'] = management_device['soortregelmiddel']\n\n    for culvert in culverts.itertuples():\n        # Generate cross section definition name\n        if culvert.vormkoker.lower() == \"rond\" or culvert.vormkoker.lower() == \"ellipsvormig\":\n            crosssection = {\"shape\": \"circle\", \"diameter\": culvert.hoogteopening}\n        elif (\n            culvert.vormkoker.lower() == \"rechthoekig\"\n            or culvert.vormkoker.lower() == \"onbekend\"\n            or culvert.vormkoker.lower() == \"eivormig\"\n            or culvert.vormkoker.lower() == \"muilprofiel\"\n            or culvert.vormkoker.lower() == \"heulprofiel\"\n        ):\n            crosssection = {\n                \"shape\": \"rectangle\",\n                \"height\": culvert.hoogteopening,\n                \"width\": culvert.breedteopening,\n                \"closed\": 1,\n            }\n        else:\n            crosssection = {\"shape\": \"circle\", \"diameter\": 0.40}\n            print(\n                f\"Culvert {culvert.code} has an unknown shape: {culvert.vormkoker}. Applying a default profile (round - 40cm)\"\n            )\n\n        # check whether an afsluitmiddel is present and take action dependent on its settings\n        if management_device is not None:\n            mandev = management_device[\n                management_device.duikersifonhevelid == culvert.globalid\n            ]\n            if 'soortafsluitmiddel' not in mandev:\n                mandev.loc[mandev.index,'soortafsluitmiddel'] = mandev['soortregelmiddel']\n        else:\n            mandev = pd.DataFrame()\n\n        if mandev.empty:\n            allowedflowdir = \"both\"\n            valveonoff = 0\n            numlosscoeff = None\n            valveopeningheight = 0\n            relopening = None\n            losscoeff = None\n        else:\n            for _, i in mandev.iterrows():\n                if i[\"soortafsluitmiddel\"] == \"terugslagklep\":\n                    allowedflowdir = \"positive\"\n                    valveonoff = 0\n                    numlosscoeff = None\n                    valveopeningheight = 0\n                    relopening = None\n                    losscoeff = None\n                elif i[\"soortafsluitmiddel\"] == \"schuif\":\n                    allowedflowdir = \"positive\"\n                    valveonoff = 1\n                    valveopeningheight = float(i[\"hoogteopening\"])\n                    numlosscoeff = 1\n                    relopening = [float(i[\"hoogteopening\"]) / culvert.hoogteopening]\n                    losscoeff = [float(i[\"afvoercoefficient\"])]\n                else:\n                    raise NotImplementedError(\n                        f'Type of management device for culvert {culvert.code} is not implemented; only \"schuif\" and \"terugslagklep\" are allowed.'\n                    )\n\n        # check if a separate name field is present\n        if \"naam\" in culverts:\n            name = culvert.naam\n        else:\n            name = culvert.code\n\n        self.structures.add_culvert(\n            id=culvert.code,\n            name=name,\n            branchid=culvert.branch_id,\n            chainage=culvert.branch_offset,\n            leftlevel=culvert.hoogtebinnenonderkantbov,\n            rightlevel=culvert.hoogtebinnenonderkantbene,\n            length=culvert.lengte,\n            inletlosscoeff=culvert.intreeverlies,\n            outletlosscoeff=culvert.uittreeverlies,\n            crosssection=crosssection,\n            allowedflowdir=allowedflowdir,\n            valveonoff=valveonoff,\n            numlosscoeff=numlosscoeff,\n            valveopeningheight=valveopeningheight,\n            relopening=relopening,\n            losscoeff=losscoeff,\n            bedfrictiontype=culvert.typeruwheid,\n            bedfriction=culvert.ruwheid,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.culverts_from_datamodel","title":"<code>culverts_from_datamodel(culverts: pd.DataFrame) -&gt; None</code>","text":"<p>From parsed model of culverts</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef culverts_from_datamodel(self, culverts: pd.DataFrame) -&gt; None:\n    \"\"\"\n    From parsed model of culverts\n    \"\"\"\n\n    # Add to dict\n    for culvert_idx, culvert in culverts.iterrows():\n        self.structures.add_culvert(\n            id=culvert.id,\n            name=culvert.name if \"name\" in culvert.index else np.nan,\n            branchid=culvert.branch_id,\n            chainage=culvert.branch_offset,\n            leftlevel=culvert.leftlevel,\n            rightlevel=culvert.rightlevel,\n            crosssection=culvert.crosssectiondefinitionid,\n            length=culvert.geometry.length\n            if \"geometry\" in culvert.index\n            else culvert.length,\n            inletlosscoeff=culvert.inletlosscoeff,\n            outletlosscoeff=culvert.outletlosscoeff,\n            allowedflowdir=\"both\",\n            valveonoff=0,\n            numlosscoeff=0,\n            valveopeningheight=np.nan,\n            relopening=np.nan,\n            losscoeff=np.nan,\n            frictiontype=culvert.frictiontype,\n            frictionvalue=culvert.frictionvalue,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.generalstructures_from_datamodel","title":"<code>generalstructures_from_datamodel(generalstructures: pd.DataFrame) -&gt; None</code>","text":"<p>From parsed data model of orifices</p> <p>Parameters:</p> Name Type Description Default <code>generalstructures</code> <code>DataFrame</code> <p>dataframe containing the data</p> required Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef generalstructures_from_datamodel(self, generalstructures: pd.DataFrame) -&gt; None:\n    \"\"\"From parsed data model of orifices\n\n    Args:\n        generalstructures (pd.DataFrame): dataframe containing the data\n    \"\"\"\n\n    for generalstructure_idx, generalstructure in generalstructures.iterrows():\n        self.structures.add_generalstructure(\n            id=generalstructure.id,\n            name=generalstructure.name\n            if \"name\" in generalstructure.index\n            else np.nan,\n            branchid=generalstructure.branch_id,\n            chainage=generalstructure.branch_offset,\n            allowedflowdir=\"both\",\n            upstream1width=generalstructure.upstream1width\n            if \"upstream1width\" in generalstructure.index\n            else np.nan,\n            upstream1level=generalstructure.upstream1level\n            if \"upstream1level\" in generalstructure.index\n            else np.nan,\n            upstream2width=generalstructure.upstream2width\n            if \"upstream2width\" in generalstructure.index\n            else np.nan,\n            upstream2level=generalstructure.upstream2level\n            if \"upstream2level\" in generalstructure.index\n            else np.nan,\n            crestwidth=generalstructure.crestwidth\n            if \"crestwidth\" in generalstructure.index\n            else np.nan,\n            crestlevel=generalstructure.crestlevel\n            if \"crestlevel\" in generalstructure.index\n            else np.nan,\n            crestlength=generalstructure.crestlength\n            if \"crestlength\" in generalstructure.index\n            else np.nan,\n            downstream1width=generalstructure.downstream1width\n            if \"downstream1width\" in generalstructure.index\n            else np.nan,\n            downstream1level=generalstructure.downstream1level\n            if \"downstream1level\" in generalstructure.index\n            else np.nan,\n            downstream2width=generalstructure.downstream2width\n            if \"downstream2width\" in generalstructure.index\n            else np.nan,\n            downstream2level=generalstructure.downstream2level\n            if \"downstream2level\" in generalstructure.index\n            else np.nan,\n            gateloweredgelevel=generalstructure.gateloweredgelevel\n            if \"gateloweredgelevel\" in generalstructure.index\n            else np.nan,\n            posfreegateflowcoeff=generalstructure.posfreegateflowcoeff\n            if \"posfreegateflowcoeff\" in generalstructure.index\n            else np.nan,\n            posdrowngateflowcoeff=generalstructure.posdrowngateflowcoeff\n            if \"posdrowngateflowcoeff\" in generalstructure.index\n            else np.nan,\n            posfreeweirflowcoeff=generalstructure.posfreeweirflowcoeff\n            if \"posfreeweirflowcoeff\" in generalstructure.index\n            else np.nan,\n            posdrownweirflowcoeff=generalstructure.posdrownweirflowcoeff\n            if \"posdrownweirflowcoeff\" in generalstructure.index\n            else np.nan,\n            poscontrcoeffreegate=generalstructure.poscontrcoeffreegate\n            if \"poscontrcoeffreegate\" in generalstructure.index\n            else np.nan,\n            negfreegateflowcoeff=generalstructure.negfreegateflowcoeff\n            if \"negfreegateflowcoeff\" in generalstructure.index\n            else np.nan,\n            negdrowngateflowcoeff=generalstructure.negdrowngateflowcoeff\n            if \"negdrowngateflowcoeff\" in generalstructure.index\n            else np.nan,\n            negfreeweirflowcoeff=generalstructure.negfreeweirflowcoeff\n            if \"negfreeweirflowcoeff\" in generalstructure.index\n            else np.nan,\n            negdrownweirflowcoeff=generalstructure.negdrownweirflowcoeff\n            if \"negdrownweirflowcoeff\" in generalstructure.index\n            else np.nan,\n            negcontrcoeffreegate=generalstructure.negcontrcoeffreegate\n            if \"negcontrcoeffreegate\" in generalstructure.index\n            else np.nan,\n            extraresistance=generalstructure.extraresistance\n            if \"extraresistance\" in generalstructure.index\n            else np.nan,\n            gateheight=generalstructure.gateheight\n            if \"gateheight\" in generalstructure.index\n            else np.nan,\n            gateopeningwidth=generalstructure.gateopeningwidth\n            if \"gateopeningwidth\" in generalstructure.index\n            else np.nan,\n            gateopeninghorizontaldirection=generalstructure.gateopeninghorizontaldirection\n            if \"gateopeninghorizontaldirection\" in generalstructure.index\n            else np.nan,\n            usevelocityheight=generalstructure.usevelocityheight\n            if \"usevelocityheight\" in generalstructure.index\n            else np.nan,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.move_structure","title":"<code>move_structure(struc, struc_dict, branch, offset)</code>  <code>staticmethod</code>","text":"<p>Function the move a structure if needed for a compound structure.</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.move_structure--parameters","title":"Parameters","text":"<p>struc : string     current sub-structure id struc_dict : dict     dict with all structures of a certain type branch : string     branch id of the first structure in the compound offset : float     chainage of the first structure in the compound</p>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.move_structure--returns","title":"Returns","text":"<p>Dict with shifted coordinates.</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@staticmethod\ndef move_structure(struc, struc_dict, branch, offset):\n    \"\"\"\n    Function the move a structure if needed for a compound structure.\n\n    Parameters\n    ----------\n    struc : string\n        current sub-structure id\n    struc_dict : dict\n        dict with all structures of a certain type\n    branch : string\n        branch id of the first structure in the compound\n    offset : float\n        chainage of the first structure in the compound\n\n    Returns\n    -------\n    Dict with shifted coordinates.\n\n    \"\"\"\n    branch2 = struc_dict[struc][\"branchid\"]\n    if branch2 != branch:\n        logger.warning(\n            f\"Structures of not on the same branche. Moving structure {struc} to branch {branch}.\"\n        )\n    struc_dict[struc][\"branchid\"] = branch\n    struc_dict[struc][\"chainage\"] = offset\n    return struc_dict\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.orifices_from_datamodel","title":"<code>orifices_from_datamodel(orifices: pd.DataFrame) -&gt; None</code>","text":"<p>\"From parsed data model of orifices</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef orifices_from_datamodel(self, orifices: pd.DataFrame) -&gt; None:\n    \"\"\" \"From parsed data model of orifices\"\"\"\n    for orifice_idx, orifice in orifices.iterrows():\n        self.structures.add_orifice(\n            id=orifice.id,\n            name=orifice.name if \"name\" in orifice.index else np.nan,\n            branchid=orifice.branch_id,\n            chainage=orifice.branch_offset,\n            allowedflowdir=\"both\",\n            crestlevel=orifice.crestlevel,\n            crestwidth=orifice.crestwidth,\n            gateloweredgelevel=orifice.gateloweredgelevel,\n            corrcoeff=orifice.corrcoef,\n            uselimitflowpos=orifice.uselimitflowpos,\n            limitflowpos=orifice.limitflowpos,\n            uselimitflowneg=orifice.uselimitflowneg,\n            limitflowneg=orifice.limitflowneg,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.pumps","title":"<code>pumps(pumpstations: ExtendedGeoDataFrame, pumps: ExtendedDataFrame = None, management: ExtendedDataFrame = None) -&gt; None</code>","text":"<p>Method to convert HyDAMO pumps to DFlowFM pumps. Three objects are required: pumpstations, pumps and management ('sturing').</p> <p>Parameters corrspond to the HyDAMO DAMO2.2 objects.</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef pumps(\n    self,\n    pumpstations: ExtendedGeoDataFrame,\n    pumps: ExtendedDataFrame = None,\n    management: ExtendedDataFrame = None,\n) -&gt; None:\n    \"\"\"\n    Method to convert HyDAMO pumps to DFlowFM pumps. Three objects are required: pumpstations, pumps and management ('sturing').\n\n    Parameters corrspond to the HyDAMO DAMO2.2 objects.\n    \"\"\"\n\n    # Add sturing to pumps\n    for pumpstation in pumpstations.itertuples():\n\n        # find pumps for gemaal\n        pumps_subset = pumps[pumps.gemaalid == pumpstation.globalid]\n        if pumps_subset.empty:\n            print(f'Skipping {pumpstation.code} because there is no associated pump.')\n            continue\n\n        if \"naam\" in pumpstation:\n            name = pumpstation.name\n        else:\n            name = pumpstation.code\n        if pumps_subset.shape[0] &gt; 1:\n            # more than one pump\n            cmp_list = []\n            print(f'Pumpstation {pumpstation.code} contains {pumps_subset.shape[0]} openings. Creating a compound structure with a fictional pump for each one.')\n            for ipump, (_,pump) in enumerate(pumps_subset.iterrows()):\n\n                pump_control = management[management.pompid== pump.globalid]\n                if pump_control.empty:\n                    print(f'No management found for {pump.code}')\n                    continue\n\n                startlevelsuctionside = [pump_control[\"bovengrens\"]]\n                stoplevelsuctionside = [pump_control[\"ondergrens\"]]\n\n                pumpid = f'{pumpstation.code}_{ipump+1}'\n                cmp_list.append(pumpid)\n\n                self.structures.add_pump(\n                    id=pumpid,\n                    name=name,\n                    branchid=pumpstation.branch_id,\n                    chainage=pumpstation.branch_offset,\n                    orientation=\"positive\",\n                    numstages=1,\n                    controlside=\"suctionside\",\n                    capacity=pump.maximalecapaciteit/60.,\n                    startlevelsuctionside=startlevelsuctionside,\n                    stoplevelsuctionside=stoplevelsuctionside,\n                    startleveldeliveryside=startlevelsuctionside,\n                    stopleveldeliveryside=stoplevelsuctionside,\n                )\n            self.structures.add_compound(id=f'cmp_{pumpstation.code}', structureids =cmp_list)\n\n        else:\n            #  only one pump\n            pump_control = management[management.pompid== pumps_subset.globalid.values[0]]\n            if pump_control.empty:\n                print(f'Skipping {pumpstation.code} because there is no associated management.')\n\n            startlevelsuctionside = [pump_control[\"bovengrens\"]]\n            stoplevelsuctionside = [pump_control[\"ondergrens\"]]\n\n\n            # the pumpstation has only one pump\n            self.structures.add_pump(\n                id=pumpstation.code,\n                name=name,\n                branchid=pumpstation.branch_id,\n                chainage=pumpstation.branch_offset,\n                orientation=\"positive\",\n                numstages=1,\n                controlside=\"suctionside\",\n                capacity=pumps_subset.maximalecapaciteit.values[0]/60.,\n                startlevelsuctionside=startlevelsuctionside,\n                stoplevelsuctionside=stoplevelsuctionside,\n                startleveldeliveryside=startlevelsuctionside,\n                stopleveldeliveryside=stoplevelsuctionside,\n            )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.pumps_from_datamodel","title":"<code>pumps_from_datamodel(pumps: pd.DataFrame) -&gt; None</code>","text":"<p>From parsed data model of pumps</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef pumps_from_datamodel(self, pumps: pd.DataFrame) -&gt; None:\n    \"\"\"From parsed data model of pumps\"\"\"\n\n    for pump_idx, pump in pumps.iterrows():\n        self.structures.add_pump(\n            id=pump.id,\n            name=pump.name if \"name\" in pump.index else np.nan,\n            branchid=pump.branch_id,\n            chainage=pump.branch_offset,\n            orientation=\"positive\",\n            numstages=1,\n            controlside=pump.controlside,\n            capacity=pump.maximumcapacity,\n            startlevelsuctionside=pump.startlevelsuctionside,\n            stoplevelsuctionside=pump.stoplevelsuctionside,\n            startleveldeliveryside=pump.startleveldeliveryside,\n            stopleveldeliveryside=pump.stopleveldeliveryside,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.uweirs_from_datamodel","title":"<code>uweirs_from_datamodel(uweirs: pd.DataFrame) -&gt; None</code>","text":"<p>\"From parsed data model of universal weirs</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef uweirs_from_datamodel(self, uweirs: pd.DataFrame) -&gt; None:\n    \"\"\" \"From parsed data model of universal weirs\"\"\"\n    for uweir_idx, uweir in uweirs.iterrows():\n        self.structures.add_uweir(\n            id=uweir.id,\n            name=uweir.name if \"name\" in uweir.index else np.nan,\n            branchid=uweir.branch_id,\n            chainage=uweir.branch_offset,\n            crestlevel=uweir.crestlevel,\n            yvalues=uweir.yvalues,\n            zvalues=uweir.zvalues,\n            allowedflowdir=\"both\",\n            dischargecoeff=uweir.dischargecoeff,\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.weirs","title":"<code>weirs(weirs: ExtendedGeoDataFrame = None, profile_groups=None, profile_lines=None, profiles: Optional[ExtendedGeoDataFrame] = None, opening: ExtendedDataFrame = None, management_device: ExtendedDataFrame = None, usevelocityheight: Optional[str] = 'true') -&gt; None</code>","text":"<p>Method to convert HyDAMO weirs to DFlowFM structures: regular weirs, orifices and universal weirs. If a weir ID corresponds to a 'stuwid' in the profile_groups object, a universal weir is created. If the management_device corresponding to a weir has the field \"overlaatonderlaat\" set to \"onderlaat', an orifice is schematized. In all other cases, a regular (rectangular) weir is created.</p> <p>Parameters corrspond to the HyDAMO DAMO2.2 objects. DFlowFM keyword 'usevelocityheight' can be specificied as a string, default is 'true'.</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef weirs(\n    self,\n    weirs: ExtendedGeoDataFrame = None,\n    profile_groups = None,\n    profile_lines = None,\n    profiles: Optional[ExtendedGeoDataFrame] = None,\n    opening: ExtendedDataFrame = None,\n    management_device: ExtendedDataFrame = None,\n    usevelocityheight: Optional[str] = \"true\",\n) -&gt; None:\n    \"\"\"\n    Method to convert HyDAMO weirs to DFlowFM structures: regular weirs, orifices and universal weirs.\n    If a weir ID corresponds to a 'stuwid' in the profile_groups object, a universal weir is created.\n    If the management_device corresponding to a weir has the field \"overlaatonderlaat\" set to \"onderlaat', an orifice is schematized. In all other cases, a regular (rectangular) weir is created.\n\n    Parameters corrspond to the HyDAMO DAMO2.2 objects. DFlowFM keyword 'usevelocityheight' can be specificied as a string, default is 'true'.\n    \"\"\"\n    # bypass HyDAMO and add stuwid directly to managment for use in RTC\n    if not self.structures.hydamo.management.empty:\n        self.structures.hydamo.management['stuwid'] = None\n\n    index = np.zeros((len(weirs.code)))\n    if profile_groups is not None and hasattr(profile_groups, \"stuwid\"):\n        index[np.isin(weirs.globalid, np.asarray(profile_groups.stuwid))] = 1\n\n    rweirs = weirs[index == 0]\n    for weir in rweirs.itertuples():\n        weir_opening = opening[opening.stuwid == weir.globalid]\n\n        # check if a separate name field is present\n        if \"naam\" in weirs:\n            name = weir.naam\n            if not name:\n                name = weir.code\n        else:\n            name = weir.code\n\n        if weir_opening.shape[0] &gt; 1:\n            print(f'Weir {weir.code} contains {weir_opening.shape[0]} openings. Creating a compound structure with a fictional weir for each one.')\n            cmp_list = []\n            for num_op, (_, op_row) in enumerate(weir_opening.iterrows()):\n                weir_mandev = management_device[\n                    management_device.kunstwerkopeningid\n                    == op_row.globalid\n                ]\n                weir_id = f'{weir.code}_{num_op+1}'\n                if (not self.structures.hydamo.management.empty) &amp; (hasattr(self.structures.hydamo.management, 'regelmiddelid')):\n                    if weir_mandev.globalid.isin(self.structures.hydamo.management.regelmiddelid).item():\n                        idx = self.structures.hydamo.management[self.structures.hydamo.management.regelmiddelid == weir_mandev.globalid.squeeze()].index.values[0]\n                        self.structures.hydamo.management.loc[idx, 'stuwid'] =weir_id\n                if weir_mandev.overlaatonderlaat.squeeze().lower() == 'overlaat':\n                    cmp_list.append(weir_id)\n                    self.structures.add_rweir(id=weir_id,\n                                                name=name,\n                                                branchid=weir.branch_id,\n                                                chainage=weir.branch_offset,\n                                                crestlevel=op_row.laagstedoorstroomhoogte,\n                                                crestwidth=op_row.laagstedoorstroombreedte,\n                                                corrcoeff=weir.afvoercoefficient,\n                                                allowedflowdir=\"both\",\n                                                usevelocityheight=usevelocityheight,\n                                             )\n                elif weir_mandev.overlaatonderlaat.squeeze().lower() == 'onderlaat':\n                    cmp_list.append(weir_id)\n                    if \"maximaaldebiet\" not in weir_mandev or pd.isnull(weir_mandev.maximaaldebiet.values[0]):\n                        limitflow = \"false\"\n                        maxq = 0.0\n                    else:\n                        limitflow = \"true\"\n                        maxq = float(weir_mandev.maximaaldebiet.values[0])\n                    self.structures.add_orifice(\n                        id=weir_id,\n                        name=name,\n                        branchid=weir.branch_id,\n                        chainage=weir.branch_offset,\n                        crestlevel=float(weir_opening.laagstedoorstroomhoogte.values[0]),\n                        crestwidth=float(weir_opening.laagstedoorstroombreedte.values[0]),\n                        corrcoeff=weir.afvoercoefficient,\n                        allowedflowdir=\"both\",\n                        usevelocityheight=usevelocityheight,\n                        gateloweredgelevel=float(weir_opening.laagstedoorstroomhoogte.values[0])\n                        + float(weir_mandev.hoogteopening.values[0]),\n                        uselimitflowpos=limitflow,\n                        limitflowpos=maxq,\n                        uselimitflowneg=limitflow,\n                        limitflowneg=maxq,\n                    )\n                else:\n                    print(f'Skipping {weir.code} - from \"overlaatonderlaat\" {weir_mandev.overlaatonderlaat} the type of structure could not be determined.')\n            self.structures.add_compound(id=f'cmp_{weir.code}', structureids =cmp_list)\n            # self.structures.rweirs_df.drop(weir.code)\n        else:\n            if weir_opening.empty:\n                print(f'Skipping {weir.code} because there is no associated opening.')\n                continue\n\n            weir_id = weir.code\n            weir_mandev = management_device[\n                    management_device.kunstwerkopeningid\n                    == weir_opening.globalid.values[0]\n                ]\n\n            if weir_mandev.empty:\n                print(f'Skipping {weir.code} because there is no associated management device.')\n                continue\n\n            if (not self.structures.hydamo.management.empty) &amp; hasattr(self.structures.hydamo.management, 'regelmiddelid'):\n                if weir_mandev.globalid.isin(self.structures.hydamo.management.regelmiddelid).item():\n                    idx = self.structures.hydamo.management[self.structures.hydamo.management.regelmiddelid == weir_mandev.globalid.squeeze()].index.values[0]\n                    self.structures.hydamo.management.loc[idx, 'stuwid'] = weir_id\n\n\n            if isinstance(weir_mandev.overlaatonderlaat, pd.Series):\n                overlaatonderlaat = weir_mandev.overlaatonderlaat.squeeze()\n            else:\n                overlaatonderlaat = weir_mandev.overlaatonderlaat\n\n            if (\n                overlaatonderlaat.lower()\n                == \"overlaat\"\n            ):\n                self.structures.add_rweir(\n                    id=weir_id,\n                    name=name,\n                    branchid=weir.branch_id,\n                    chainage=weir.branch_offset,\n                    crestlevel=weir_opening.laagstedoorstroomhoogte.values[0],\n                    crestwidth=weir_opening.laagstedoorstroombreedte.values[0],\n                    corrcoeff=weir.afvoercoefficient,\n                    allowedflowdir=\"both\",\n                    usevelocityheight=usevelocityheight,\n                )\n\n            elif (\n                overlaatonderlaat.lower()\n                == \"onderlaat\"\n            ):\n                if \"maximaaldebiet\" not in weir_mandev or pd.isnull(weir_mandev.maximaaldebiet.values[0]):\n                    limitflow = \"false\"\n                    maxq = 0.0\n                else:\n                    limitflow = \"true\"\n                    maxq = float(weir_mandev.maximaaldebiet.values[0])\n                self.structures.add_orifice(\n                    id=weir_id,\n                    name=name,\n                    branchid=weir.branch_id,\n                    chainage=weir.branch_offset,\n                    crestlevel=float(weir_opening.laagstedoorstroomhoogte.values[0]),\n                    crestwidth=float(weir_opening.laagstedoorstroombreedte.values[0]),\n                    corrcoeff=weir.afvoercoefficient,\n                    allowedflowdir=\"both\",\n                    usevelocityheight=usevelocityheight,\n                    gateloweredgelevel=float(weir_opening.laagstedoorstroomhoogte.values[0])\n                    + float(weir_mandev.hoogteopening.values[0]),\n                    uselimitflowpos=limitflow,\n                    limitflowpos=maxq,\n                    uselimitflowneg=limitflow,\n                    limitflowneg=maxq,\n                )\n            else:\n                print(f'Skipping {weir.code} - from \"overlaatonderlaat\" {weir_mandev.overlaatonderlaat} the type of structure could not be determined.')\n\n    uweirs = weirs[index == 1]\n    for uweir in uweirs.itertuples():\n        # check if a separate name field is present\n        if \"naam\" in uweirs:\n            name = uweir.naam\n        else:\n            name = uweir.code\n\n        prof = np.empty(0)\n        if (profiles is not None) &amp; (\"stuwid\" in profile_groups):\n            group = profile_groups[profile_groups[\"stuwid\"] == uweir.globalid]\n            line = profile_lines[\n                profile_lines[\"profielgroepid\"] == group[\"globalid\"].values[0]\n            ]\n            prof = profiles[profiles[\"profiellijnid\"] == line[\"globalid\"].values[0]]\n            if not prof.empty:\n                counts = len(prof.geometry.iloc[0].coords[:])\n                xyz = np.vstack(prof.geometry.iloc[0].coords[:])\n                length = np.r_[\n                    0,\n                    np.cumsum(np.hypot(np.diff(xyz[:, 0]), np.diff(xyz[:, 1]))),\n                ]\n                yzvalues = np.c_[length, xyz[:, -1] - np.min(xyz[:, -1])]\n\n        if not hasattr(uweir, 'laagstedoorstroomhoogte') or pd.isnull(uweir.laagstedoorstroomhoogte):\n            kruinhoogte = np.min(xyz[:,-1])\n        else:\n            kruinhoogte = uweir.laagstedoorstroomhoogte\n\n        if len(prof) == 0:\n            # return an error it is still not found\n            raise ValueError(f\"{uweir.code} is not found in any cross-section.\")\n        self.structures.add_uweir(\n            id=uweir.code,\n            name=name,\n            branchid=uweir.branch_id,\n            chainage=uweir.branch_offset,\n            crestlevel=kruinhoogte,\n            dischargecoeff=uweir.afvoercoefficient,\n            allowedflowdir=\"both\",\n            numlevels=counts,\n            yvalues=\" \".join([f\"{yz[0]:7.3f}\" for yz in yzvalues]),\n            zvalues=\" \".join([f\"{yz[1]:7.3f}\" for yz in yzvalues]),\n        )\n</code></pre>"},{"location":"dhydamo/reference/api/#hydrolib.dhydamo.converters.hydamo2df.StructuresIO.weirs_from_datamodel","title":"<code>weirs_from_datamodel(weirs: pd.DataFrame) -&gt; None</code>","text":"<p>\"From parsed data model of weirs</p> Source code in <code>hydrolib/dhydamo/converters/hydamo2df.py</code> <pre><code>@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef weirs_from_datamodel(self, weirs: pd.DataFrame) -&gt; None:\n    \"\"\" \"From parsed data model of weirs\"\"\"\n    for weir_idx, weir in weirs.iterrows():\n        self.structures.add_weir(\n            id=weir.id,\n            name=weir.name if \"name\" in weir.index else np.nan,\n            branchid=weir.branch_id,\n            chainage=weir.branch_offset,\n            crestlevel=weir.crestlevel,\n            crestwidth=weir.crestwidth,\n            corrcoeff=weir.corrcoeff,\n        )\n</code></pre>"},{"location":"guides/contributing/","title":"Contributing","text":""},{"location":"guides/contributing/#tooling","title":"Tooling","text":""},{"location":"guides/contributing/#black","title":"Black","text":"<p>We use <code>black</code> as an autoformatter. It is also run during CI and will fail if it's not formatted beforehand.</p>"},{"location":"guides/contributing/#isort","title":"Isort","text":"<p>We use <code>isort</code> as an autoformatter.</p>"},{"location":"guides/contributing/#commitizen","title":"Commitizen","text":"<p>We use <code>commitizen</code> to automatically bump the version number. If you use conventional commit messages, the <code>changelog.md</code> is generated automatically.</p>"},{"location":"guides/documentation/","title":"Documentation","text":"<p>We use MKdocs for documentation. For full documentation visit mkdocs.org.</p>"},{"location":"guides/documentation/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"guides/documentation/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"guides/setup/","title":"Installation","text":"<p>You should be able to install HYDROLIB with: <pre><code>pip install hydrolib\n</code></pre></p> <p>or if you prefer (especially on Windows)</p> <pre><code>conda install hydrolib -c conda-forge\n</code></pre> <p>Note</p> <p>If you use <code>conda</code>, it's advisable to install HYDROLIB within a new environment with only <code>conda-forge</code> as channel. </p>"},{"location":"include/mkdocs-macros/main/","title":"Main","text":"In\u00a0[\u00a0]: Copied! <pre>def define_env(env):\n    \"\"\"\n    Set up specific environment for documentation site,\n    with some convenience macro's.\n\n    Available custom mkdocs-macros that produce Markdown content:\n    { sobek_um(anchor, linktext) }: (deep)link to SOBEK User Manual PDF.\n    { dflowfm_um(anchor, linktext) }: (deep)link to D-Flow FM User Manual PDF.\n    { gh_issue(number, linktext) }: link to GitHub issue page.\n    { gh_pr(number, linktext) }: link to GitHub pull request page.\n\n    \"\"\"\n\n    dflowfm_um_url = (\n        \"https://content.oss.deltares.nl/delft3d/manuals/D-Flow_FM_User_Manual_1D2D.pdf\"\n    )\n    sobek_um_url = (\n        \"https://content.oss.deltares.nl/delft3d/manuals/SOBEK_User_Manual.pdf\"\n    )\n    hydrolib_core_url = \"https://github.com/Deltares/HYDROLIB-core\"\n\n    def _get_url(url: str, anchor: str = None):\n        return url + (\"#\" + anchor if anchor else \"\")\n\n    @env.macro\n    def dflowfm_um(anchor: str = \"\", linktext: str = \"D-Flow FM UM\"):\n        \"\"\"Create Markdown link for D-Flow FM User Manual, with optional anchor/bookmark.\"\"\"\n\n        return \"[\" + linktext + \"](\" + _get_url(dflowfm_um_url, anchor) + \")\"\n\n    @env.macro\n    def sobek_um(anchor: str = \"\", linktext: str = \"SOBEK UM\"):\n        \"\"\"Create Markdown link for SOBEK User Manual, with optional anchor/bookmark.\"\"\"\n\n        return \"[\" + linktext + \"](\" + _get_url(sobek_um_url, anchor) + \")\"\n\n    @env.macro\n    def gh_issue(number: int, linktext: str = None):\n        \"\"\"Create Markdown link to GitHub issue page.\"\"\"\n\n        return (\n            \"[\"\n            + (linktext or \"#\" + str(number))\n            + \"](\"\n            + hydrolib_core_url\n            + \"/issues/\"\n            + str(number)\n            + \")\"\n        )\n\n    @env.macro\n    def gh_pr(number: int, linktext: str = None):\n        \"\"\"Create Markdown link to GitHub pull request page.\"\"\"\n\n        return (\n            \"[\"\n            + (linktext or \"#\" + str(number))\n            + \"](\"\n            + hydrolib_core_url\n            + \"/pull/\"\n            + str(number)\n            + \")\"\n        )\n</pre> def define_env(env):     \"\"\"     Set up specific environment for documentation site,     with some convenience macro's.      Available custom mkdocs-macros that produce Markdown content:     { sobek_um(anchor, linktext) }: (deep)link to SOBEK User Manual PDF.     { dflowfm_um(anchor, linktext) }: (deep)link to D-Flow FM User Manual PDF.     { gh_issue(number, linktext) }: link to GitHub issue page.     { gh_pr(number, linktext) }: link to GitHub pull request page.      \"\"\"      dflowfm_um_url = (         \"https://content.oss.deltares.nl/delft3d/manuals/D-Flow_FM_User_Manual_1D2D.pdf\"     )     sobek_um_url = (         \"https://content.oss.deltares.nl/delft3d/manuals/SOBEK_User_Manual.pdf\"     )     hydrolib_core_url = \"https://github.com/Deltares/HYDROLIB-core\"      def _get_url(url: str, anchor: str = None):         return url + (\"#\" + anchor if anchor else \"\")      @env.macro     def dflowfm_um(anchor: str = \"\", linktext: str = \"D-Flow FM UM\"):         \"\"\"Create Markdown link for D-Flow FM User Manual, with optional anchor/bookmark.\"\"\"          return \"[\" + linktext + \"](\" + _get_url(dflowfm_um_url, anchor) + \")\"      @env.macro     def sobek_um(anchor: str = \"\", linktext: str = \"SOBEK UM\"):         \"\"\"Create Markdown link for SOBEK User Manual, with optional anchor/bookmark.\"\"\"          return \"[\" + linktext + \"](\" + _get_url(sobek_um_url, anchor) + \")\"      @env.macro     def gh_issue(number: int, linktext: str = None):         \"\"\"Create Markdown link to GitHub issue page.\"\"\"          return (             \"[\"             + (linktext or \"#\" + str(number))             + \"](\"             + hydrolib_core_url             + \"/issues/\"             + str(number)             + \")\"         )      @env.macro     def gh_pr(number: int, linktext: str = None):         \"\"\"Create Markdown link to GitHub pull request page.\"\"\"          return (             \"[\"             + (linktext or \"#\" + str(number))             + \"](\"             + hydrolib_core_url             + \"/pull/\"             + str(number)             + \")\"         )"},{"location":"reference/api/","title":"API","text":"<p>This is the automatically generated part of the code, based on the docstrings in modules, classes and functions from functionality shared by multiple tools in HYDROLIB. See the individual tools' API docs for their own technical documentation.</p>"},{"location":"tools/tools_introduction/","title":"Introduction of tools","text":"<p>Multiple tools are developed and shared through the HYDROLIB repository. An overview of these tools with their connections is given in the image below. </p>"}]}